create a new programming langague called `Language X` that is close to pseudo code and has minimal boilerplate, python is a greate example, but don't use all of python's syntax, javascript is also a good example, but let's mix and match different syntrax to get the most easy language to write mixing all the good features of every one and avoid any of the extra stuff that comes with tradiational programming languages;
the programming language will also implement types and for that we will use the typescript typing syntax;
This langugae is designed for developers to make prompt engineering easier by using this programming language to prompt the chat model.
Both the model and the user must agree on the language syntax for common and basic programming features, like looping, logging to the console.

# Function declration

```x
// Function do not have a body, function declration are only written in the below syntax and should never include a body!
// Function names must always start with a verb e.g `add` or `get` or `set` or `delete` etc... and must me camelCased
func getRandomNumber () => $randomNumber: number // returns a random number
func addTwoNumbers ($x: number, $y: number) => $sum: number // returns the sum of $x and $y
```

# Variables

```x
// Can be either delcared using const or let
const sum: number = addTwoNumbers(2, 3) // $sum is equal to 5
// But to reference a variable you have to use $ as a prfix:
const newSum = addTwoNumbers($sum, 1) // $newSum is equal to 6
```

# Using functions from other programming language:

```x
// Built-functions of other language are supported as long they only deal with primitive values which are either strings, numbers or booleans.
// It also supports arrays, but they have to be arrays of primitive values, e.g array of strings, numbers or booleans
// To use the .sort() function from javascript:
```

```x
const unsortedList = [3, 1, 1]
const list = js:sort($unsortedList) // this clones $unsortedList into $list and then sorts $list
// this is equivalnt to:
func sort($list: array) => $sortedList: array // returns a sorted clone of $list
// but the addition of `js:` implies that the default javascript sorting algorithm should be used to sort these elements and this will also be used by transpilers / interperters to generate code using javascript for this line
```

# Immutability

In `Language X` all functions must return a value, it is a purely functional programming language where there is no concept of objects or oop, and as such it should be assumed that all functions imported from another language will not modify variables in place and will instead clone their arguments and create a new reference in memory

```x
// using different variants of the same function e.g `Array.sort()` and `Array.toSorted()` does not have any effect and the result is still the same, the only difference is the naming
const list = js:toSorted([3, 2, 1])
```

# Some common functions

```x
// valid code
const list = ['a', 'b', 'c']
const listLength = py:len($list) // $listLength is equal to 3
```

```x
// invalid code !
const list = ['a', 'b', 'c']
const listLength = list.length // error! LanguageX does not support any form dot notation or object access modifiers
// You may however use indices to get elements of an array:
const list = ['a', 'b', 'c']
const firstElement = $list[0] // if list[0] is empty accessing elements this way will produce an error!
```

# Loops

there is only one type of loop in `X` which is the for do loop:

```x
for $elem in $list
    do `sh:echo $elem` // prints $elem to stdout
```

multiple do statement:

```x
for $elem in $list
    do `const planet = 'earth'`
    do `sh:echo $elem + $planet` // prints $elem + $plant (string aggregation)
```

With loop variable:

```x
const _ = py:range(0, 5)
for $index in _
    do `echo $index` // outputs 0, 1, 2, 3, 4
```

# AI

A special syntax may be used to instruct llms to generate values dynamcilly to be used in the script.

```x
sh:echo({{ string: a random joke }}) // when an llm sees this it should substitute what's between the `{{` and the `}}` with the prompt inside it.
// so an llm should read the above line as `sh:echo <a string of a random hoke>.
```

You may also assign varibles using this syntax:

```x
const randomHumanName = {{ string: random name of a human}};
// in which case randomHumanName's value is generated by the llm and then put back into the source file.
```

# Asynchronous Programming

async/await is not supported in `X`. To write asynchrounous code you can use the following syntax:

```x
func[4] fetchWeatherData($country: string) => <$weatherData: string[]> // fetches $weatherData from th server filtered by $country
// the number 4` here indicates the max time a single network request should take. and a TIMEOUT error is thrown if the request didn't complete within 4 seconds of the request. This is handled internally by using the Promise.race() javascript function `js:race` ,`4` seconds is usually a very big timeout if you are just fetching json data from the server as it usually takes milliseconds to send/receive hunbders of enteries beteween client and server.
when the return of a function is put between `<` and `>` this marks the variable as asynchronus and it resolves to a Response object.
A docker proxy server running in the middle of the client and the server handles incoming requests from the client and responses from the server.
actint as a controller, this proxy server also uses ssh keys to encrypy and decrypt data between server and client in secure way.
The proxy server also handle convertion of `Response` objects coming from the server to JSON.parse({body of the response}).
meaning it only extracts a plain javascript object (that can be represented in json) and sends it to the client. and does the reverse for the client. when the client sends a Request objects to the server, the proxy server also extracts a plain javascript object from the response that is usually the body of the request and forwards it to the main server.
communication between the client - proxy server - main server is secured using ssh keys and digital signatures.
but sometimes if you are uploading a file or an image the request may take longer in that case you can mark the function as infinite:
func[âˆž] postImageFiles(files: string[]) => response: Response // Native `Response` inteface for both node and browser
```

````x
//you can also use the string `infinity` instead.
func[infinity] keepFetchingUntilServerTimesout() => <void>;


# Await
```x
// the `use` operator is equivalnt to `await`, however it will validate the data against the async function's return type using zod schemas and if the type does not match a validation error will be thrown!
const data = use fetchWeatherData('New Zealend')
// At this point data is validated and awaited and the `data` variable is a list of string.
for $elem in $data
    do `sh:echo $elem` // outputs 23, 32, 23, etc..
````

# Database operations

The `Database` in `LanguageX` is a key-value documents database stored as josn.
There are TWO databased in `X`.
The first one is the server based database and the second one is the client side database.
And then there is a `shadow` database that can be used to store shared database key/values pairs.
This `shadow` database is initialized on the server, populated with keys that the server wants to share with the client. On first client load; the `shadow` database is sent to the client as cookies. This is also a two-way data sharing mechanism; by making the server send extra shared keys with no value to the client, (like the server send the client a key called `userName` with no value), this allows the client to set the value by itself using a POST request to the server with the value for the key.
The server then has control whether to sync that change on the server.
Once the server has decieded what to do with the received data in the post request, it sends the user a hash of the value it received. This hash is generated by using the user's public ssh key to digitally sign the data.
All POST requests from the client to the server must include a `userId` in the body of the request.
The value of `userId` is treated as the public ssh key of the user and is used to digitally sign data sent from the server to the client.
Respectivly, all responses from POST request include the `serverId` key/value pair in the response body. This `serverId` is treated as the server's public ssh key.
The user uses client side authentication methods to generate both a private and a public ssh key.
The user's private ssh key is generated by any authentication method preferabbable as long as it generated both a private and a publick ssh key.
Once the private key is generated on the client, it is turned into a hash using the server's publick ssh key `serverId` which can be found by making a GET request to `/handshake/id` which returns the key as raw text.
After the client users `serverId` to turn their private ssh key into a hash, they delete the private key from the client and send the generated hash to the server.
The client then either asks the user for a `password` that will be used to encrypt the hash or use a JWT token or biometric authentication or single-sign-onn sso.

```x
// ! Example workflow:
func[3.5] postData($data: string[], $url: string) => <$response:Response> e // The native Javascript V8 `Response` interface. or throws a timeout error after 3.5 seconds.

```

# Conditionals and optional chaining

```x
// You can use if statements in `X`
const data = postData(['a', 'b', 'c'], "/test")
// the `use` operator automacilly returns the validated response body data against zod schemas, which means you get intellisense if you have setup your zod schemas.
// the `use` operator also 'await' the data
const validatedData = use $data
// you can now access properties on the validated data. however properties are stored as arrays and not obects!
// for example:
const someObject = {someProp: 'someValue'} // ! invalid
instead data is validated and returned as a matrix.
It mimics a sqllite structure tables;
```

# Database Structure

Data in `X` is stored as a matrix (2D array). The first array contains the schema, and subsequent arrays contain the actual data.

```x
// Example database structure
const db = [
    // Schema definition
    [
        ["id", [
            ["type", "number"],
            ["@unique", true],
            ["@id", true]
        ]],
        ["name", [
            ["type", "string"],
            ["@unique", true],
            ["@id", false]
        ]],
        ["email", [
            ["type", "string"],
            ["@unique", true],
            ["@id", false]
        ]]
    ],
    // Data rows
    [1, "John", "john@email.com"],
    [2, "Alice", "alice@email.com"],
    [3, "Bob", "bob@email.com"]
]

// Accessing data
const firstRow = $db[1] // Returns [1, "John", "john@email.com"]
const johnName = $db[1][1] // Returns "John"
```

This structure allows for type safety and schema validation while keeping the data format simple and efficient.

# ORM

`X` comes with its own ORM that can integrate with any database.
`Prisma` or `lowdb` or `mainfest.js` or even just a local dev.db file with a sqlite3 database.

## Usage:

// generates code to interact with prisma
// needs exporting of enviroment varibles to work correctly
// you will need to setup a .env file with keys like:
// = PRISMA_ROOT_FOLDER="./prisma
// - PRISMA_SCHEMA_PATH="./prisma/prisma.schema.ts"
// - ... and some more (check prisma docks)
// the generated code uses `process.env[key]` to read enviroment varibles.
// .env files are loaded by default and made accessible to prisma.
const dataPromise = prisma[4]:getData() // max 4 seconds
const data = use dataPromise // data fetched and validated

# Other ORMs

YOu can also other ORMs lke Drizzle... etc.
you can also use either deno or bun for the runtime.
you can use bun or deno special features together in the same app wiwthout having to switch or change anything. everhting is avalaible with zero config.

## So you can run

```x
LanguageX does NOT use objects of any kind, but since array is actually an object in some language like javascript you can still emulate oop behavior, however that is very discourged and the prefered way is to use array string only.
This format unifies server and client communication

type Cat = [
    [string, string], // schema row: column names
    [string, string], // schema row: types
    ...[string, number][] // data rows
]
```

```x
const catsPromise = bun:sql[20]('SELECT \* FROM cats')
const cats : Cat[]= use catsPromise // now you have intellesense
js:log(js:stringfy(cats))
// outputs:
[
[["name", "age"],
["string", "number"]],
["Whiskers", 3],
["Luna", 2],
["Shadow", 4],
["Milo", 1],
["Bella", 5]
]

```

# Proxy Server

Communicatin between client and server are managed by the proxy server.
the proxy server is a private server owned by you (can even be your own laptop) that sits between the server and the client.
It has an admin panel that lets you configure and manage both client and server at the same time.

and as such this server should be kept private and limits access to certain users only (can be a docker image as well) (you can deploy bun server or deno servers or vercel).

the proxy server admin panel has the followig settings and methods: - toggle proxy server on/off - toggle demo mode on/off - switch themems - add CMS content - generate zod schemas script - validate script - setup request/response maps (or use trpc/grpc)

The proxy server is a monorepo that has several packages: - endpoints - generate - validate - generatedData - index.ts
It uses nx monorepo under the hood.

## endpoints

type defiintions and configuration of api endpoints, this is required if you are going to use the proxy server.
for each url or 'endpoint' in your api you should add an endpoint object that has the type `AppEndpoint` exported by the `endpoints` package.
`AppEndpoint` consists of many properties, as an example:

const testEndpoint = [
// Schema definition
["url", "/api/test"],
["method", "POST"],
["requestSchema", [
["status", "string"],
["message", "string"]
]],
["responseSchema", [
["success", "boolean"],
["data", "string[]"]
]],
["exampleRequest", [
"ok",
"test message"
]],
["exampleResponse", [
true,
["data1", "data2"]
]]
]
const testEndpoint = [
["url", "requestSchema", "exampleRequestBody"],
["string', "ZodTypeAny", "z.infer<typeof requestSchema>]],
["/ap/test", "[["status"], ["string"], ['ok]]", [['status"], "string",], ["ok]]

## generate

this scrirpt calls all endpoints defined in the `endpoints` package using the `exampleRequestBody` and a post request.
It then stores the response in an example-{endpoint}-{operation}.json file.
using the json file and a library called `json-to-zod` it generated zod schemas based on the response of each endpoint.
then it copies the fetched json file to the root of the package `generatedData`'s `responseSchemas` folder.
the command sets up all schemas with import/export statement and uses the name defined in your `endpoints` package to generate the zod schema names.

Cross-origin-policy is restriected both on the client and the server and the proxy so only allowed domain on all three components of the app have the same cross-origin-policy the proxy server will be disabled and you will have to setup a backend yourself (maybe vercel)

once the resposneSchemas are genereated. you have to manually edit the root inde.ts file of the proxy server to export the newly generated endpoint.

# Server Actions with Next.js

For Next.js v15 with server actions, there is a global helper function:

```x
// Helper function for form actions
func getFormAction($endpoint: URL, $method: string) => $action: FormFunction
// where method is one of: "list" | "details" | "create" | "delete" | "update"
// returns a function that handles form data submission

// Example usage:
const submitHandler = getFormAction("/api/users", "create")
```

The returned action function handles:

- Form data validation
- Request/response type safety
- Error handling
- Loading states

Usage in Next.js components:

```x
// In a Next.js component
const form = getFormAction("/api/posts", "create")
do `<form action={$form}>
    <input name="title" />
    <button type="submit">Create</button>
</form>`
//If you want to use Next.js v15 with server actions you have a helper function that is globally defined but here it is anyways:
func getFormAction(endpoint: URL, method: "list" | "details" | "create" | "delete" | update ) => (formData: FormData) => {}
```

# How does mixing programming languages work?

in LanguageX you can import and use function from different programming language like rust, javascript and python.
how does that work?
well, the proxy server has access to a sandboxes docker container that has most programming language installed including ruby!
then when the interpeter encouters a line like:

```x
js:log('hello workd')
```

it runs a `docker exec` command to execute the javascript code using the node installation in the container.
sample command to run the above code inside the container will look like:

```sh
docker exec lang-x-container node -e "console.log('hello world')"
```

and it does the same for all languages, piping your input into the native function of the programming language and then extracting the output to the global frame.

# Userful Functions

## getFormAction() => (formData: FormData) => [["id", "name"],["number", "string"]]

Used to handle form submissions in Next.js server actions:

```x
// Create form handler
const submitHandler = getFormAction("/api/users", "create")

// Handles:
- Form validation
- Type safety
- Error states  
- Loading states
```

Example usage:

```x
// In Next.js component
const form = getFormAction("/api/posts", "create") 
do `<form action={$form}>
    <input name="title" />
    <button>Submit</button>
</form>`
```

## getFormAction() => (formData: FormData) => [["id", "name"],["number", "string] ]

Check `packages/actions/server/getFormAction.ts`