<repomix>This file is a merged representation of the entire codebase, combined into a single document by Repomix. The content has been processed where line numbers have been added, content has been formatted for parsing.<file_summary>This section contains a summary of this file.<purpose>This file contains a packed representation of the entire repository&apos;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Line numbers have been added to the beginning of each line
- Content has been formatted for parsing in xml style</notes><additional_info></additional_info></file_summary><directory_structure>.repomix/
  bundles.json
packages/
  actions/
    getAiResponse.ts
    package.json
    tsconfig.json
  archieve/
    aiResponse/
      json/
        add two numbers with javascript.json
        Adds two numbers and returns the sum..json
        Adds two numbers..json
        Pulls the latest Arch Linux image from Docker Hub. This function does not take any arguments..json
        Pulls the latest Arch Linux image from Docker Hub..json
        reverse a string with python.json
        Reverses a given string. This is the first part of the string reversal process..json
        run the arch linux docker image with shell functions.json
        running arch linux using the docker cli.json
        Runs an Arch Linux container with the specified command. This is the first part of the function..json
        Runs an Arch Linux container with the specified command..json
        Takes a string as input and returns its reversed version..json
    taskTrees/
      _add_two_numbers_with_javascript.json
      _reverse_a_string_with_python.json
      _run_the_arch_linux_docker_image_with_shell_functions.json
      _running_arch_linux_using_the_docker_cli.json
    generateFunctionTree copy.ts
    package.json
    tsconfig.json
  config/
    index.ts
    package.json
    tsconfig.json
  docs/
    bun/
      plugins.md
      workspaces.md
    gemini/
      example.ts
      models.md
    ronin/
      LanguageX.md
    package.json
  hooks/
    package.json
    tsconfig.json
    useFormAction.ts
  prompts/
    getPlanPrompt.ts
    getSplitTaskPrompt.ts
    package.json
    tsconfig.json
  scripts/
    coder.ts
    package.json
    tsconfig.json
  test/
    server/
      actions/
        testExecuteCommand.ts
        tsconfig.json
    package.json
    tsconfig.json
  utils/
    package.json
    sleep.ts
    tsconfig.json
.gitignore
bun.lock
index.ts
package.json
README.md
tsconfig.json</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".repomix/bundles.json">1: {
2:   &quot;bundles&quot;: {}
3: }</file><file path="packages/actions/getAiResponse.ts"> 1: import { file, write } from &quot;bun&quot;;
 2: import { GoogleGenerativeAI, ResponseSchema } from &quot;@google/generative-ai&quot;;
 3: 
 4: const apiKey = process.env.GEMINI_API_KEY as string;
 5: const googleGenAi = new GoogleGenerativeAI(apiKey);
 6: 
 7: type GetAiResponseArgs = {
 8:   prompt: string;
 9:   // context?: string;
10:   responseMimeType?: &quot;text&quot; | &quot;application/json&quot; | &quot;text/md&quot;;
11:   responseSchema?: ResponseSchema;
12:   task?: string;
13: };
14: 
15: export const getAiResponse = async ({
16:   task,
17:   prompt,
18:   // context,
19:   responseMimeType,
20:   responseSchema,
21: }: GetAiResponseArgs) =&gt; {
22:   // const aiStart = performance.now();
23:   // console.log(&quot;AI start&quot;, aiStart);
24:   const genModel = googleGenAi.getGenerativeModel({
25:     model: aiModelNameString,
26:     // systemInstruction: systemInstruction,
27:     generationConfig: {
28:       // candidateCount,
29:       // frequencyPenalty,
30:       candidateCount: 1,
31:       // logprobs,
32:       // maxOutputTokens,
33:       // presencePenalty,
34:       // stopSequences,
35:       // temperature
36:       // topK,
37:       // topP,
38:       responseMimeType,
39:       responseSchema,
40:     },
41:   });
42:   // const { response } = await genModel.generateContent(prompt);
43:   const genContent = await genModel.generateContent(prompt);
44: 
45:   const { response } = genContent;
46:   const { text } = response;
47: 
48:   const responseText = text();
49:   console.log(JSON.parse(responseText));
50:   const aiResponseFile = file(&quot;aiResponse/json/&quot; + (task ?? prompt) + &quot;.json&quot;);
51:   await write(aiResponseFile, responseText);
52:   // console.log(aiResponseFile.name);
53:   // const aiEnd = performance.now();
54:   // console.log(`AI took ${(aiEnd - aiStart) / 1000} seconds`);
55:   return responseText;
56:   // ! ========================================================================
57: };
58: 
59: // interface AiResponse {
60: //   functionCallResult?: any;
61: //   genContent?: any;
62: //   functionCalls?: any;
63: //   candidates?: Array&lt;{
64: //     content: {
65: //       parts: Array&lt;{
66: //         codeExecutionResult?: any;
67: //         executableCode?: any;
68: //         fileData?: any;
69: //         functionCall?: any;
70: //         functionResponse?: any;
71: //         inlineData?: any;
72: //         text?: string;
73: //       }&gt;;
74: //       role?: string;
75: //     };
76: //     index?: number;
77: //     avgLogprobs?: any;
78: //     citationMetadata?: any;
79: //     finishMessage?: any;
80: //     finishReason?: any;
81: //     groundingMetadata?: any;
82: //     logprobsResult?: any;
83: //     safetyRatings?: any;
84: //   }&gt;;
85: //   promptFeedback?: any;
86: //   usageMetadata?: any;
87: // }</file><file path="packages/actions/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/actions&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;@google/generative-ai&quot;: &quot;^0.21.0&quot;,
 8:     &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 9:     &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
10:     &quot;bun-types&quot;: &quot;latest&quot;,
11:     &quot;zod&quot;: &quot;1&quot;
12:   }
13: }</file><file path="packages/actions/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;esnext&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path="packages/archieve/aiResponse/json/add two numbers with javascript.json">1: [{
2:   &quot;arguments&quot;: &quot;a: number, b: number&quot;,
3:   &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
4:   &quot;functionName&quot;: &quot;addNumbers&quot;,
5:   &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
6:   &quot;returns&quot;: &quot;number&quot;,
7:   &quot;shouldBeSplit&quot;: false
8: }]</file><file path="packages/archieve/aiResponse/json/Adds two numbers and returns the sum..json">1: [{&quot;arguments&quot;: &quot;number, number&quot;, &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;, &quot;functionName&quot;: &quot;addNumbers&quot;, &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;, &quot;returns&quot;: &quot;number&quot;, &quot;shouldBeSplit&quot;: false}]</file><file path="packages/archieve/aiResponse/json/Adds two numbers..json">1: []</file><file path="packages/archieve/aiResponse/json/Pulls the latest Arch Linux image from Docker Hub. This function does not take any arguments..json">1: [{
2:   &quot;arguments&quot;: &quot;null&quot;,
3:   &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub.&quot;,
4:   &quot;functionName&quot;: &quot;pullLatestArchLinuxImage&quot;,
5:   &quot;isPrimeFunction&quot;: true,
6:   &quot;pseudocode&quot;: &quot;1. Use the Docker CLI to pull the &apos;archlinux&apos; image.\n2. Output success or failure.&quot;,
7:   &quot;returns&quot;: &quot;string&quot;
8: }]</file><file path="packages/archieve/aiResponse/json/Pulls the latest Arch Linux image from Docker Hub..json"> 1: [{
 2:   &quot;arguments&quot;: &quot;&quot;,
 3:   &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub. This function does not take any arguments.&quot;,
 4:   &quot;functionName&quot;: &quot;pullArchLinuxImage&quot;,
 5:   &quot;isPrimeFunction&quot;: false,
 6:   &quot;pseudocode&quot;: &quot;function pullArchLinuxImage() {\n  // 1. Define the image name\n  // 2. Execute docker pull command with the image name\n}\n\nfunction getImageName() {\n  // 1. Returns the image name \&quot;archlinux:latest\&quot;\n}\n&quot;,
 7:   &quot;returns&quot;: &quot;string&quot;
 8: },{
 9:   &quot;arguments&quot;: &quot;&quot;,
10:   &quot;description&quot;: &quot;Retrieves the Arch Linux image name.&quot;,
11:   &quot;functionName&quot;: &quot;getImageName&quot;,
12:   &quot;isPrimeFunction&quot;: true,
13:   &quot;pseudocode&quot;: &quot;function getImageName() {\n  // Returns the image name \&quot;archlinux:latest\&quot;\n}\n&quot;,
14:   &quot;returns&quot;: &quot;string&quot;
15: }]</file><file path="packages/archieve/aiResponse/json/reverse a string with python.json"> 1: [{
 2:   &quot;arguments&quot;: &quot;string&quot;,
 3:   &quot;description&quot;: &quot;Reverses a string using Python&apos;s string slicing.&quot;,
 4:   &quot;functionName&quot;: &quot;reverse_string&quot;,
 5:   &quot;isPrimeFunction&quot;: true,
 6:   &quot;pseudocode&quot;: &quot;return the string sliced from the end to the beginning with a step of -1&quot;,
 7:   &quot;returns&quot;: &quot;string&quot;
 8: },
 9: {
10:   &quot;arguments&quot;: &quot;string&quot;,
11:   &quot;description&quot;: &quot;Takes a string as input and returns its reversed version.&quot;,
12:   &quot;functionName&quot;: &quot;reverse_string_with_split_and_join&quot;,
13:   &quot;isPrimeFunction&quot;: false,
14:   &quot;pseudocode&quot;: &quot;Split the string into a list of characters. Reverse the list of characters. Join the list of characters back into a string. Return the reversed string&quot;,
15:   &quot;returns&quot;: &quot;string&quot;
16: }]</file><file path="packages/archieve/aiResponse/json/Reverses a given string. This is the first part of the string reversal process..json"> 1: [{
 2:   &quot;arguments&quot;: &quot;string&quot;,
 3:   &quot;description&quot;: &quot;Reverses a given string. This is the first part of the string reversal process.&quot;,
 4:   &quot;functionName&quot;: &quot;reverseStringFirstPart&quot;,
 5:   &quot;isPrimeFunction&quot;: false,
 6:   &quot;pseudocode&quot;: &quot;function reverseStringFirstPart(str):\n  return str.split(&apos;&apos;).reverse().join(&apos;&apos;)&quot;,
 7:   &quot;returns&quot;: &quot;string&quot;
 8: }, {
 9:   &quot;arguments&quot;: &quot;string&quot;,
10:   &quot;description&quot;: &quot;Reverses a given string.&quot;,
11:   &quot;functionName&quot;: &quot;reverseString&quot;,
12:   &quot;isPrimeFunction&quot;: true,
13:   &quot;pseudocode&quot;: &quot;function reverseString(str):\n  reversed = reverseStringFirstPart(str)\n  return reversed&quot;,
14:   &quot;returns&quot;: &quot;string&quot;
15: }]</file><file path="packages/archieve/aiResponse/json/run the arch linux docker image with shell functions.json">1: [{
2:   &quot;arguments&quot;: &quot;string&quot;,
3:   &quot;description&quot;: &quot;Run the arch linux docker image with shell functions&quot;,
4:   &quot;functionName&quot;: &quot;runArchLinuxDocker&quot;,
5:   &quot;pseudocode&quot;: &quot;func runArchLinuxDocker(commands: string) =&gt; string\n{\n  docker run --rm -it archlinux bash -c commands\n}&quot;,
6:   &quot;returns&quot;: &quot;string&quot;,
7:   &quot;shouldBeSplit&quot;: false
8: }]</file><file path="packages/archieve/aiResponse/json/running arch linux using the docker cli.json"> 1: [{
 2:   &quot;arguments&quot;: &quot;none&quot;,
 3:   &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub.&quot;,
 4:   &quot;functionName&quot;: &quot;pullArchLinuxImage&quot;,
 5:   &quot;isPrimeFunction&quot;: false,
 6:   &quot;pseudocode&quot;: &quot;docker pull archlinux&quot;,
 7:   &quot;returns&quot;: &quot;string&quot;
 8: }, {
 9:   &quot;arguments&quot;: &quot;string&quot;,
10:   &quot;description&quot;: &quot;Runs an Arch Linux container with the specified command.&quot;,
11:   &quot;functionName&quot;: &quot;runArchLinuxContainer&quot;,
12:   &quot;isPrimeFunction&quot;: false,
13:   &quot;pseudocode&quot;: &quot;docker run -it archlinux &lt;command&gt;&quot;,
14:   &quot;returns&quot;: &quot;string&quot;
15: }]</file><file path="packages/archieve/aiResponse/json/Runs an Arch Linux container with the specified command. This is the first part of the function..json">1: []</file><file path="packages/archieve/aiResponse/json/Runs an Arch Linux container with the specified command..json"> 1: [{
 2:   &quot;arguments&quot;: &quot;command: string&quot;,
 3:   &quot;description&quot;: &quot;Runs an Arch Linux container with the specified command. This is the first part of the function.&quot;,
 4:   &quot;functionName&quot;: &quot;runArchLinuxContainer_setup&quot;,
 5:   &quot;isPrimeFunction&quot;: false,
 6:   &quot;pseudocode&quot;: &quot;1. Create a temporary directory.\n2. Pull the Arch Linux Docker image.\n3. Start a Docker container using the Arch Linux image and mount the temporary directory.\n4. Return the container ID.&quot;,
 7:   &quot;returns&quot;: &quot;containerId: string&quot;
 8: }, {
 9:   &quot;arguments&quot;: &quot;containerId: string, command: string&quot;,
10:   &quot;description&quot;: &quot;Runs a command inside an existing Arch Linux container. This is the second part of the function.&quot;,
11:   &quot;functionName&quot;: &quot;runArchLinuxContainer_execute&quot;,
12:   &quot;isPrimeFunction&quot;: true,
13:   &quot;pseudocode&quot;: &quot;1. Execute the specified command inside the Docker container using docker exec.\n2. Return the output and exit code.&quot;,
14:   &quot;returns&quot;: &quot;output: string, exitCode: number&quot;
15: }]</file><file path="packages/archieve/aiResponse/json/Takes a string as input and returns its reversed version..json"> 1: [
 2:   {
 3:     &quot;arguments&quot;: &quot;string&quot;,
 4:     &quot;description&quot;: &quot;Reverses a given string. This is the first part of the string reversal process.&quot;,
 5:     &quot;functionName&quot;: &quot;reverseStringFirstPart&quot;,
 6:     &quot;isPrimeFunction&quot;: false,
 7:     &quot;pseudocode&quot;: &quot;1. Initialize an empty string called &apos;reversed_string&apos;.\n2. Iterate through the input string from the end to the beginning.\n3. In each iteration, append the current character to &apos;reversed_string&apos;.\n4. Return the &apos;reversed_string&apos;.&quot;,
 8:     &quot;returns&quot;: &quot;string&quot;
 9:   },
10:   {
11:     &quot;arguments&quot;: &quot;string&quot;,
12:     &quot;description&quot;: &quot;Reverses a given string. This is the second part of the string reversal process.&quot;,
13:     &quot;functionName&quot;: &quot;reverseStringSecondPart&quot;,
14:     &quot;isPrimeFunction&quot;: false,
15:     &quot;pseudocode&quot;: &quot;1. Call the reverseStringFirstPart function with the input string.\n2. Return the result of the function call.&quot;,
16:     &quot;returns&quot;: &quot;string&quot;
17:   }
18: ]</file><file path="packages/archieve/taskTrees/_add_two_numbers_with_javascript.json">  1: {
  2:     &quot;task&quot;: {
  3:         &quot;functionName&quot;: &quot;add two numbers with javascript&quot;,
  4:         &quot;arguments&quot;: &quot;{string&quot;,
  5:         &quot;returns&quot;: &quot;none&quot;,
  6:         &quot;description&quot;: &quot;add two numbers with javascript&quot;,
  7:         &quot;shouldBeSplit&quot;: true,
  8:         &quot;pseudocode&quot;: &quot;(input) =&gt; reverseOfInput&quot;
  9:     },
 10:     &quot;subTasks&quot;: [
 11:         {
 12:             &quot;task&quot;: {
 13:                 &quot;functionName&quot;: &quot;addNumbers&quot;,
 14:                 &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 15:                 &quot;shouldBeSplit&quot;: false,
 16:                 &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
 17:                 &quot;arguments&quot;: &quot;a: number, b: number&quot;,
 18:                 &quot;returns&quot;: &quot;number&quot;
 19:             },
 20:             &quot;subTasks&quot;: [
 21:                 {
 22:                     &quot;task&quot;: {
 23:                         &quot;functionName&quot;: &quot;addNumbers&quot;,
 24:                         &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 25:                         &quot;shouldBeSplit&quot;: false,
 26:                         &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
 27:                         &quot;arguments&quot;: &quot;number, number&quot;,
 28:                         &quot;returns&quot;: &quot;number&quot;
 29:                     },
 30:                     &quot;subTasks&quot;: [
 31:                         {
 32:                             &quot;task&quot;: {
 33:                                 &quot;functionName&quot;: &quot;addNumbers&quot;,
 34:                                 &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 35:                                 &quot;shouldBeSplit&quot;: false,
 36:                                 &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
 37:                                 &quot;arguments&quot;: &quot;number, number&quot;,
 38:                                 &quot;returns&quot;: &quot;number&quot;
 39:                             },
 40:                             &quot;subTasks&quot;: [
 41:                                 {
 42:                                     &quot;task&quot;: {
 43:                                         &quot;functionName&quot;: &quot;addNumbers&quot;,
 44:                                         &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 45:                                         &quot;shouldBeSplit&quot;: false,
 46:                                         &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
 47:                                         &quot;arguments&quot;: &quot;number, number&quot;,
 48:                                         &quot;returns&quot;: &quot;number&quot;
 49:                                     },
 50:                                     &quot;subTasks&quot;: [
 51:                                         {
 52:                                             &quot;task&quot;: {
 53:                                                 &quot;functionName&quot;: &quot;addNumbers&quot;,
 54:                                                 &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 55:                                                 &quot;shouldBeSplit&quot;: false,
 56:                                                 &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
 57:                                                 &quot;arguments&quot;: &quot;number, number&quot;,
 58:                                                 &quot;returns&quot;: &quot;number&quot;
 59:                                             },
 60:                                             &quot;subTasks&quot;: [
 61:                                                 {
 62:                                                     &quot;task&quot;: {
 63:                                                         &quot;functionName&quot;: &quot;addNumbers&quot;,
 64:                                                         &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 65:                                                         &quot;shouldBeSplit&quot;: false,
 66:                                                         &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
 67:                                                         &quot;arguments&quot;: &quot;a: number, b: number&quot;,
 68:                                                         &quot;returns&quot;: &quot;number&quot;
 69:                                                     },
 70:                                                     &quot;subTasks&quot;: [
 71:                                                         {
 72:                                                             &quot;task&quot;: {
 73:                                                                 &quot;functionName&quot;: &quot;addNumbers&quot;,
 74:                                                                 &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 75:                                                                 &quot;shouldBeSplit&quot;: false,
 76:                                                                 &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
 77:                                                                 &quot;arguments&quot;: &quot;a: number, b: number&quot;,
 78:                                                                 &quot;returns&quot;: &quot;number&quot;
 79:                                                             },
 80:                                                             &quot;subTasks&quot;: [
 81:                                                                 {
 82:                                                                     &quot;task&quot;: {
 83:                                                                         &quot;functionName&quot;: &quot;addNumbers&quot;,
 84:                                                                         &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 85:                                                                         &quot;shouldBeSplit&quot;: false,
 86:                                                                         &quot;pseudocode&quot;: &quot;function addNumbers(num1, num2):\n  return num1 + num2&quot;,
 87:                                                                         &quot;arguments&quot;: &quot;num1: number, num2: number&quot;,
 88:                                                                         &quot;returns&quot;: &quot;number&quot;
 89:                                                                     },
 90:                                                                     &quot;subTasks&quot;: [
 91:                                                                         {
 92:                                                                             &quot;task&quot;: {
 93:                                                                                 &quot;functionName&quot;: &quot;add&quot;,
 94:                                                                                 &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
 95:                                                                                 &quot;shouldBeSplit&quot;: false,
 96:                                                                                 &quot;pseudocode&quot;: &quot;function add(a, b) {\n  return a + b;\n}&quot;,
 97:                                                                                 &quot;arguments&quot;: &quot;number a, number b&quot;,
 98:                                                                                 &quot;returns&quot;: &quot;number&quot;
 99:                                                                             },
100:                                                                             &quot;subTasks&quot;: [
101:                                                                                 {
102:                                                                                     &quot;task&quot;: {
103:                                                                                         &quot;functionName&quot;: &quot;addNumbers&quot;,
104:                                                                                         &quot;description&quot;: &quot;Adds two numbers and returns the sum.&quot;,
105:                                                                                         &quot;shouldBeSplit&quot;: false,
106:                                                                                         &quot;pseudocode&quot;: &quot;function addNumbers(a, b) {\n  return a + b;\n}&quot;,
107:                                                                                         &quot;arguments&quot;: &quot;number, number&quot;,
108:                                                                                         &quot;returns&quot;: &quot;number&quot;
109:                                                                                     },
110:                                                                                     &quot;subTasks&quot;: []
111:                                                                                 }
112:                                                                             ]
113:                                                                         }
114:                                                                     ]
115:                                                                 }
116:                                                             ]
117:                                                         }
118:                                                     ]
119:                                                 }
120:                                             ]
121:                                         }
122:                                     ]
123:                                 }
124:                             ]
125:                         }
126:                     ]
127:                 }
128:             ]
129:         }
130:     ]
131: }</file><file path="packages/archieve/taskTrees/_reverse_a_string_with_python.json"> 1: {
 2:     &quot;task&quot;: {
 3:         &quot;functionName&quot;: &quot;reverse a string with python&quot;,
 4:         &quot;arguments&quot;: &quot;{string&quot;,
 5:         &quot;returns&quot;: &quot;none&quot;,
 6:         &quot;description&quot;: &quot;reverse a string with python&quot;,
 7:         &quot;isPrimeFunction&quot;: false,
 8:         &quot;pseudocode&quot;: &quot;(input) =&gt; reverseOfInput&quot;
 9:     },
10:     &quot;subTasks&quot;: [
11:         {
12:             &quot;task&quot;: {
13:                 &quot;functionName&quot;: &quot;reverse_string_slice&quot;,
14:                 &quot;description&quot;: &quot;Reverses a string using slicing.&quot;,
15:                 &quot;isPrimeFunction&quot;: true,
16:                 &quot;pseudocode&quot;: &quot;return the string reversed using slicing&quot;,
17:                 &quot;arguments&quot;: &quot;string&quot;,
18:                 &quot;returns&quot;: &quot;string&quot;
19:             },
20:             &quot;subTasks&quot;: []
21:         },
22:         {
23:             &quot;task&quot;: {
24:                 &quot;functionName&quot;: &quot;reverse_string_loop&quot;,
25:                 &quot;description&quot;: &quot;Reverses a string using a loop.&quot;,
26:                 &quot;isPrimeFunction&quot;: true,
27:                 &quot;pseudocode&quot;: &quot;Iterate over the string backwards and build a new string.&quot;,
28:                 &quot;arguments&quot;: &quot;string&quot;,
29:                 &quot;returns&quot;: &quot;string&quot;
30:             },
31:             &quot;subTasks&quot;: []
32:         }
33:     ]
34: }</file><file path="packages/archieve/taskTrees/_run_the_arch_linux_docker_image_with_shell_functions.json"> 1: {
 2:     &quot;task&quot;: {
 3:         &quot;functionName&quot;: &quot;main&quot;,
 4:         &quot;arguments&quot;: &quot;void&quot;,
 5:         &quot;returns&quot;: &quot;void&quot;,
 6:         &quot;description&quot;: &quot;main task&quot;,
 7:         &quot;shouldBeSplit&quot;: true,
 8:         &quot;pseudocode&quot;: &quot;main()&quot;
 9:     },
10:     &quot;subTasks&quot;: [
11:         {
12:             &quot;task&quot;: {
13:                 &quot;functionName&quot;: &quot;runArchLinuxDocker&quot;,
14:                 &quot;description&quot;: &quot;Run the arch linux docker image with shell functions&quot;,
15:                 &quot;shouldBeSplit&quot;: false,
16:                 &quot;pseudocode&quot;: &quot;func runArchLinuxDocker(commands: string) =&gt; string\n{\n  docker run --rm -it archlinux bash -c commands\n}&quot;,
17:                 &quot;arguments&quot;: &quot;string&quot;,
18:                 &quot;returns&quot;: &quot;string&quot;
19:             },
20:             &quot;subTasks&quot;: []
21:         }
22:     ]
23: }</file><file path="packages/archieve/taskTrees/_running_arch_linux_using_the_docker_cli.json">  1: {
  2:     &quot;task&quot;: {
  3:         &quot;functionName&quot;: &quot;running arch linux using the docker cli&quot;,
  4:         &quot;arguments&quot;: &quot;{string&quot;,
  5:         &quot;returns&quot;: &quot;none&quot;,
  6:         &quot;description&quot;: &quot;running arch linux using the docker cli&quot;,
  7:         &quot;isPrimeFunction&quot;: false,
  8:         &quot;pseudocode&quot;: &quot;(input) =&gt; reverseOfInput&quot;
  9:     },
 10:     &quot;subTasks&quot;: [
 11:         {
 12:             &quot;task&quot;: {
 13:                 &quot;functionName&quot;: &quot;pullArchLinuxImage&quot;,
 14:                 &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub.&quot;,
 15:                 &quot;isPrimeFunction&quot;: false,
 16:                 &quot;pseudocode&quot;: &quot;docker pull archlinux&quot;,
 17:                 &quot;arguments&quot;: &quot;none&quot;,
 18:                 &quot;returns&quot;: &quot;string&quot;
 19:             },
 20:             &quot;subTasks&quot;: [
 21:                 {
 22:                     &quot;task&quot;: {
 23:                         &quot;functionName&quot;: &quot;pullArchLinuxImage&quot;,
 24:                         &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub.&quot;,
 25:                         &quot;isPrimeFunction&quot;: false,
 26:                         &quot;pseudocode&quot;: &quot;function pullArchLinuxImage() {\n  // 1. Define a function to pull the image using a Docker command, returning a promise or similar based on the underlying command execution.\n  // 2. Use a promise-based approach (async/await or .then()) to handle the command execution.\n  // 3. Catch any errors during the pull and handle them.\n  // 4. Return a message indicating success or failure.\n  // Example (conceptual):\n  // async function pullArchLinuxImage() {\n  //   try {\n  //     await executeDockerCommand(&apos;docker pull archlinux&apos;);\n  //     return &apos;Arch Linux image pulled successfully.&apos;;\n  //   } catch (error) {\n  //     return &apos;Error pulling Arch Linux image: &apos; + error.message;\n  //   }\n  // }\n}&quot;,
 27:                         &quot;arguments&quot;: &quot;&quot;,
 28:                         &quot;returns&quot;: &quot;string&quot;
 29:                     },
 30:                     &quot;subTasks&quot;: [
 31:                         {
 32:                             &quot;task&quot;: {
 33:                                 &quot;functionName&quot;: &quot;pull_arch_linux_image&quot;,
 34:                                 &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub.&quot;,
 35:                                 &quot;isPrimeFunction&quot;: false,
 36:                                 &quot;pseudocode&quot;: &quot;function pull_arch_linux_image():\n    // Function 1: Check if the image exists locally\n    image_exists = check_local_image()\n    // Function 2: Pull the image if it doesn&apos;t exist\n    if not image_exists:\n        pull_docker_image()\n    return \&quot;Arch Linux image pulled successfully\&quot;&quot;,
 37:                                 &quot;arguments&quot;: &quot;&quot;,
 38:                                 &quot;returns&quot;: &quot;string&quot;
 39:                             },
 40:                             &quot;subTasks&quot;: [
 41:                                 {
 42:                                     &quot;task&quot;: {
 43:                                         &quot;functionName&quot;: &quot;pull_arch_linux_image&quot;,
 44:                                         &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub.&quot;,
 45:                                         &quot;isPrimeFunction&quot;: false,
 46:                                         &quot;pseudocode&quot;: &quot;1. Define a function to pull the latest Arch Linux image.\n2. Call the docker pull command to fetch the image from Docker Hub.\n3. Optionally, provide a success/failure message.&quot;,
 47:                                         &quot;arguments&quot;: &quot;&quot;,
 48:                                         &quot;returns&quot;: &quot;string&quot;
 49:                                     },
 50:                                     &quot;subTasks&quot;: [
 51:                                         {
 52:                                             &quot;task&quot;: {
 53:                                                 &quot;functionName&quot;: &quot;pullArchLinuxImage&quot;,
 54:                                                 &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub. This function does not take any arguments.&quot;,
 55:                                                 &quot;isPrimeFunction&quot;: false,
 56:                                                 &quot;pseudocode&quot;: &quot;function pullArchLinuxImage() {\n  // 1. Define the image name\n  // 2. Execute docker pull command with the image name\n}\n\nfunction getImageName() {\n  // 1. Returns the image name \&quot;archlinux:latest\&quot;\n}\n&quot;,
 57:                                                 &quot;arguments&quot;: &quot;&quot;,
 58:                                                 &quot;returns&quot;: &quot;string&quot;
 59:                                             },
 60:                                             &quot;subTasks&quot;: [
 61:                                                 {
 62:                                                     &quot;task&quot;: {
 63:                                                         &quot;functionName&quot;: &quot;pullLatestArchImage&quot;,
 64:                                                         &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub. This function does not take any arguments.&quot;,
 65:                                                         &quot;isPrimeFunction&quot;: false,
 66:                                                         &quot;pseudocode&quot;: &quot;function pullLatestArchImage():\n  // 1. Execute the docker pull command for the archlinux image.\n  // 2. Handle potential errors (e.g., image not found, network issues).\n  // 3. Return success or failure message.\n  pass&quot;,
 67:                                                         &quot;arguments&quot;: &quot;string&quot;,
 68:                                                         &quot;returns&quot;: &quot;string&quot;
 69:                                                     },
 70:                                                     &quot;subTasks&quot;: [
 71:                                                         {
 72:                                                             &quot;task&quot;: {
 73:                                                                 &quot;functionName&quot;: &quot;pullLatestArchLinuxImage&quot;,
 74:                                                                 &quot;description&quot;: &quot;Pulls the latest Arch Linux image from Docker Hub.&quot;,
 75:                                                                 &quot;isPrimeFunction&quot;: true,
 76:                                                                 &quot;pseudocode&quot;: &quot;1. Use the Docker CLI to pull the &apos;archlinux&apos; image.\n2. Output success or failure.&quot;,
 77:                                                                 &quot;arguments&quot;: &quot;null&quot;,
 78:                                                                 &quot;returns&quot;: &quot;string&quot;
 79:                                                             },
 80:                                                             &quot;subTasks&quot;: []
 81:                                                         }
 82:                                                     ]
 83:                                                 },
 84:                                                 {
 85:                                                     &quot;task&quot;: {
 86:                                                         &quot;functionName&quot;: &quot;executeDockerPull&quot;,
 87:                                                         &quot;description&quot;: &quot;Executes the docker pull command for the specified image.&quot;,
 88:                                                         &quot;isPrimeFunction&quot;: true,
 89:                                                         &quot;pseudocode&quot;: &quot;function executeDockerPull(imageName: string): // input is the image name to pull\n  // 1. Construct the docker pull command string.\n  // 2. Execute the command using a suitable library or method (e.g., subprocess).\n  // 3. Capture the output and error streams.\n  // 4. Analyze the output to determine success or failure.\n  // 5. Return a success/failure message with relevant details.\n  pass&quot;,
 90:                                                         &quot;arguments&quot;: &quot;string&quot;,
 91:                                                         &quot;returns&quot;: &quot;string&quot;
 92:                                                     },
 93:                                                     &quot;subTasks&quot;: []
 94:                                                 }
 95:                                             ]
 96:                                         },
 97:                                         {
 98:                                             &quot;task&quot;: {
 99:                                                 &quot;functionName&quot;: &quot;getImageName&quot;,
100:                                                 &quot;description&quot;: &quot;Retrieves the Arch Linux image name.&quot;,
101:                                                 &quot;isPrimeFunction&quot;: true,
102:                                                 &quot;pseudocode&quot;: &quot;function getImageName() {\n  // Returns the image name \&quot;archlinux:latest\&quot;\n}\n&quot;,
103:                                                 &quot;arguments&quot;: &quot;&quot;,
104:                                                 &quot;returns&quot;: &quot;string&quot;
105:                                             },
106:                                             &quot;subTasks&quot;: []
107:                                         }
108:                                     ]
109:                                 },
110:                                 {
111:                                     &quot;task&quot;: {
112:                                         &quot;functionName&quot;: &quot;execute_docker_pull&quot;,
113:                                         &quot;description&quot;: &quot;Helper function to execute the docker pull command.&quot;,
114:                                         &quot;isPrimeFunction&quot;: true,
115:                                         &quot;pseudocode&quot;: &quot;1. Construct the docker pull command: &apos;docker pull archlinux/archlinux:latest&apos;.\n2. Execute the command using a subprocess or similar method.\n3. Return the result of the command execution.&quot;,
116:                                         &quot;arguments&quot;: &quot;&quot;,
117:                                         &quot;returns&quot;: &quot;string&quot;
118:                                     },
119:                                     &quot;subTasks&quot;: []
120:                                 }
121:                             ]
122:                         },
123:                         {
124:                             &quot;task&quot;: {
125:                                 &quot;functionName&quot;: &quot;check_local_image&quot;,
126:                                 &quot;description&quot;: &quot;Checks if the Arch Linux image exists locally.&quot;,
127:                                 &quot;isPrimeFunction&quot;: true,
128:                                 &quot;pseudocode&quot;: &quot;function check_local_image():\n    // Use docker command to inspect the image\n    if docker image exists:\n        return True\n    else:\n        return False&quot;,
129:                                 &quot;arguments&quot;: &quot;&quot;,
130:                                 &quot;returns&quot;: &quot;boolean&quot;
131:                             },
132:                             &quot;subTasks&quot;: []
133:                         }
134:                     ]
135:                 },
136:                 {
137:                     &quot;task&quot;: {
138:                         &quot;functionName&quot;: &quot;executeDockerCommand&quot;,
139:                         &quot;description&quot;: &quot;Executes a Docker command.&quot;,
140:                         &quot;isPrimeFunction&quot;: true,
141:                         &quot;pseudocode&quot;: &quot;function executeDockerCommand(command) {\n  // 1. Use a library or function to execute shell commands (e.g., child_process in Node.js).\n  // 2. Pass the provided `command` to the shell execution function.\n  // 3. Return a promise that resolves when the command completes.\n  // 4. If the command fails, reject the promise with an error.\n  // Example (conceptual):\n  // function executeDockerCommand(command) {\n  //   return new Promise((resolve, reject) =&gt; {\n  //     const child = exec(command, (error, stdout, stderr) =&gt; {\n  //       if (error) {\n  //         reject(error);\n  //         return;\n  //       }\n  //       resolve(stdout || stderr);\n  //     });\n  //   });\n  // }\n}&quot;,
142:                         &quot;arguments&quot;: &quot;string&quot;,
143:                         &quot;returns&quot;: &quot;string&quot;
144:                     },
145:                     &quot;subTasks&quot;: []
146:                 }
147:             ]
148:         },
149:         {
150:             &quot;task&quot;: {
151:                 &quot;functionName&quot;: &quot;runArchLinuxContainer&quot;,
152:                 &quot;description&quot;: &quot;Runs an Arch Linux container with the specified command.&quot;,
153:                 &quot;isPrimeFunction&quot;: false,
154:                 &quot;pseudocode&quot;: &quot;docker run -it archlinux &lt;command&gt;&quot;,
155:                 &quot;arguments&quot;: &quot;string&quot;,
156:                 &quot;returns&quot;: &quot;string&quot;
157:             },
158:             &quot;subTasks&quot;: [
159:                 {
160:                     &quot;task&quot;: {
161:                         &quot;functionName&quot;: &quot;runArchLinuxContainer_setup&quot;,
162:                         &quot;description&quot;: &quot;Runs an Arch Linux container with the specified command. This is the first part of the function.&quot;,
163:                         &quot;isPrimeFunction&quot;: false,
164:                         &quot;pseudocode&quot;: &quot;1. Create a temporary directory.\n2. Pull the Arch Linux Docker image.\n3. Start a Docker container using the Arch Linux image and mount the temporary directory.\n4. Return the container ID.&quot;,
165:                         &quot;arguments&quot;: &quot;command: string&quot;,
166:                         &quot;returns&quot;: &quot;containerId: string&quot;
167:                     },
168:                     &quot;subTasks&quot;: []
169:                 },
170:                 {
171:                     &quot;task&quot;: {
172:                         &quot;functionName&quot;: &quot;runArchLinuxContainer_execute&quot;,
173:                         &quot;description&quot;: &quot;Runs a command inside an existing Arch Linux container. This is the second part of the function.&quot;,
174:                         &quot;isPrimeFunction&quot;: true,
175:                         &quot;pseudocode&quot;: &quot;1. Execute the specified command inside the Docker container using docker exec.\n2. Return the output and exit code.&quot;,
176:                         &quot;arguments&quot;: &quot;containerId: string, command: string&quot;,
177:                         &quot;returns&quot;: &quot;output: string, exitCode: number&quot;
178:                     },
179:                     &quot;subTasks&quot;: []
180:                 }
181:             ]
182:         }
183:     ]
184: }</file><file path="packages/archieve/generateFunctionTree copy.ts">  1: // import { SchemaType, type ResponseSchema } from &quot;@google/generative-ai&quot;;
  2: // import { getAiResponse } from &quot;./getAiResponse&quot;;
  3: // import { getSubTasksPrompt } from &quot;./prompts/getSplitTaskPrompt&quot;;
  4: // import { sleep } from &quot;./sleep&quot;;
  5: // import { z } from &quot;zod&quot;;
  6: // import { write } from &quot;bun&quot;;
  7: 
  8: // // Define a zod schema for each task.
  9: // const TaskSchema = z.object({
 10: //   functionName: z.string(),
 11: //   description: z.string(),
 12: //   shouldBeSplit: z.boolean(),
 13: //   pseudocode: z.string(),
 14: //   arguments: z.string(),
 15: //   returns: z.string(),
 16: // });
 17: 
 18: // // Define the expected JSON schema for the API response.
 19: // const functionTreeShcema: ResponseSchema = {
 20: //   description: &quot;A tree structure of functions&quot;,
 21: //   type: SchemaType.ARRAY,
 22: //   items: {
 23: //     type: SchemaType.OBJECT,
 24: //     properties: {
 25: //       functionName: {
 26: //         type: SchemaType.STRING,
 27: //         description: &quot;Name of the function&quot;,
 28: //         nullable: false,
 29: //       },
 30: //       description: {
 31: //         type: SchemaType.STRING,
 32: //         description: &quot;Description of the function&quot;,
 33: //         nullable: false,
 34: //       },
 35: //       arguments: {
 36: //         type: SchemaType.STRING,
 37: //         description:
 38: //           &quot;Arguments shape and type of the function written as a zod schema&quot;,
 39: //         nullable: false,
 40: //       },
 41: //       returns: {
 42: //         type: SchemaType.STRING,
 43: //         description:
 44: //           &quot;Return shape and type of the function written as a zod schema&quot;,
 45: //         nullable: false,
 46: //       },
 47: //       shouldBeSplit: {
 48: //         type: SchemaType.BOOLEAN,
 49: //         description:
 50: //           &quot;Whether the function should be split into smaller functions&quot;,
 51: //         nullable: false,
 52: //       },
 53: //       pseudocode: {
 54: //         type: SchemaType.STRING,
 55: //         description:
 56: //           &quot;minimal pseudocode of the function with syntax similar to Typescript, don&apos;t inlcude any comments. for example: `func addTwoNumbers(x: number, y: number) =&gt; number (x + y)`&quot;,
 57: //         nullable: false,
 58: //       },
 59: //     },
 60: //     required: [
 61: //       &quot;functionName&quot;,
 62: //       &quot;description&quot;,
 63: //       &quot;arguments&quot;,
 64: //       &quot;returns&quot;,
 65: //       &quot;shouldBeSplit&quot;,
 66: //       &quot;pseudocode&quot;,
 67: //     ],
 68: //   },
 69: // };
 70: 
 71: // // This function sends the task to the AI and returns a JSON string representing an array of sub tasks.
 72: // export const splitTask = async (task: string): Promise&lt;string&gt; =&gt; {
 73: //   const prompt = getSubTasksPrompt(task);
 74: //   const tasks = await getAiResponse({
 75: //     task,
 76: //     prompt,
 77: //     responseMimeType: &quot;application/json&quot;,
 78: //     responseSchema: functionTreeShcema,
 79: //   });
 80: //   return tasks;
 81: // };
 82: 
 83: // // Define the basic task type returned by splitTask.
 84: // export type Task = z.infer&lt;typeof TaskSchema&gt;;
 85: 
 86: // // Define the tree node type.
 87: // export type TaskNode = {
 88: //   task: Task;
 89: //   subTasks: TaskNode[];
 90: // };
 91: 
 92: // // Global constant for maximum recursive depth.
 93: // const MAX_RECURSIVE_DEPTH = 10;
 94: 
 95: // /**
 96: //  * Recursively builds a tree branch for a given task.
 97: //  *
 98: //  * @param task - The current task to process.
 99: //  * @param currentDepth - The current depth in the recursion.
100: //  * @returns A TaskNode representing the task and its (possibly recursive) subtasks.
101: //  */
102: // const buildSubTree = async (
103: //   task: Task,
104: //   currentDepth: number
105: // ): Promise&lt;TaskNode&gt; =&gt; {
106: //   // Stop recursion if the task is basic or we&apos;ve reached the maximum depth.
107: //   if (!task.shouldBeSplit || currentDepth &gt;= MAX_RECURSIVE_DEPTH) {
108: //     return { task, subTasks: [] };
109: //   }
110: 
111: //   // Call splitTask to get the subtasks.
112: //   const responseString = await splitTask(task.description);
113: //   let subTaskResults: Task[] = JSON.parse(responseString).map((item: any) =&gt;
114: //     TaskSchema.parse(item)
115: //   );
116: 
117: //   // Limit to at most 2 subtasks.
118: //   // subTaskResults = subTaskResults.slice(0, 2);
119: 
120: //   // Recursively process each subtask.
121: //   const children: TaskNode[] = [];
122: //   for (const subTask of subTaskResults) {
123: //     const childNode = await buildSubTree(subTask, currentDepth + 1);
124: //     children.push(childNode);
125: //   }
126: 
127: //   return { task, subTasks: children };
128: // };
129: 
130: // /**
131: //  * Builds the complete task tree starting from an initial task string.
132: //  *
133: //  * The root node is created from the initial string, then splitTask is called
134: //  * to generate the first level of subtasks.
135: //  *
136: //  * @param initialTask - The initial task as a string.
137: //  * @returns A TaskNode representing the full tree.
138: //  */
139: // export const buildTaskTree = async (initialTask: string): Promise&lt;TaskNode&gt; =&gt; {
140: //   // Create a root TaskResult from the input string.
141: //   const rootTask: Task = {
142: //     functionName: &quot;main&quot;,
143: //     arguments: &quot;void&quot;,
144: //     returns: &quot;void&quot;,
145: //     description: &quot;main task&quot;,
146: //     shouldBeSplit: true,
147: //     pseudocode: &quot;main()&quot;,
148: //   };
149: 
150: //   // Split the root task into subtasks.
151: //   const responseString = await splitTask(initialTask);
152: //   let subTaskResults: Task[] = JSON.parse(responseString).map((item: any) =&gt;
153: //     TaskSchema.parse(item)
154: //   );
155: 
156: //   // Limit to at most 2 subtasks.
157: //   // subTaskResults = subTaskResults.slice(0, 2);
158: 
159: //   // Build the children recursively.
160: //   const children: TaskNode[] = [];
161: //   for (const subTask of subTaskResults) {
162: //     const childNode = await buildSubTree(subTask, 1);
163: //     children.push(childNode);
164: //   }
165: 
166: //   return { task: rootTask, subTasks: children };
167: // };
168: 
169: // const MAIN_TASK = &quot;run the arch linux docker image with shell functions&quot;;
170: 
171: // const taskTree = await buildTaskTree(MAIN_TASK);
172: 
173: // console.log(JSON.stringify(taskTree, null, 2));
174: // const taskTreeFilePath =
175: //   &quot;./taskTrees/&quot; +
176: //   Date.now().toFixed().slice(-1, -4) +
177: //   &quot;_&quot; +
178: //   MAIN_TASK.replaceAll(&quot; &quot;, &quot;_&quot;) +
179: //   &quot;.json&quot;;
180: // // write(taskTreeFilePath, JSON.stringify(taskTree, null, 4));
181: // // console.log(taskTreeFilePath);
182: // write(&quot;./functionTree.json&quot;, JSON.stringify(taskTree, null, 2));</file><file path="packages/archieve/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/archieve&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 8:     &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 9:     &quot;bun-types&quot;: &quot;latest&quot;,
10:     &quot;zod&quot;: &quot;1&quot;
11:   }
12: }</file><file path="packages/archieve/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;esnext&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path="packages/config/index.ts">1: // export const aiModel = &quot;gemini-2.0-flash-thinking-exp&quot;;
2: export const aiModelNameString = &quot;gemini-2.0-flash-lite-preview-02-05&quot;;
3: export const systemInstruction = &quot;Only reply in json format&quot;;
4: export default {
5:   aiModelNameString,
6:   systemInstruction,
7: };</file><file path="packages/config/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/config&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 8:     &quot;bun-types&quot;: &quot;latest&quot;,
 9:     &quot;zod&quot;: &quot;1&quot;
10:   }
11: }</file><file path="packages/config/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;bundler&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path="packages/docs/bun/plugins.md">  1: Bun provides a universal plugin API that can be used to extend both the _runtime_ and [_bundler_](https://bun.sh/docs/bundler).
  2: 
  3: Plugins intercept imports and perform custom loading logic: reading files, transpiling code, etc. They can be used to add support for additional file types, like `.scss` or `.yaml`. In the context of Bun&apos;s bundler, plugins can be used to implement framework-level features like CSS extraction, macros, and client-server code co-location.
  4: 
  5: ## Usage
  6: 
  7: A plugin is defined as simple JavaScript object containing a `name` property and a `setup` function. Register a plugin with Bun using the `plugin` function.
  8: 
  9: ```tsx#myPlugin.ts
 10: import { plugin, type BunPlugin } from &quot;bun&quot;;
 11: 
 12: const myPlugin: BunPlugin = {
 13:   name: &quot;Custom loader&quot;,
 14:   setup(build) {
 15:     // implementation
 16:   },
 17: };
 18: 
 19: plugin(myPlugin);
 20: ```
 21: 
 22: Plugins have to be loaded before any other code runs! To achieve this, use the `preload` option in your [`bunfig.toml`](https://bun.sh/docs/runtime/bunfig). Bun automatically loads the files/modules specified in `preload` before running a file.
 23: 
 24: ```toml
 25: preload = [&quot;./myPlugin.ts&quot;]
 26: ```
 27: 
 28: To preload files before `bun test`:
 29: 
 30: ```toml
 31: [test]
 32: preload = [&quot;./myPlugin.ts&quot;]
 33: ```
 34: 
 35: ## Third-party plugins
 36: 
 37: By convention, third-party plugins intended for consumption should export a factory function that accepts some configuration and returns a plugin object.
 38: 
 39: ```ts
 40: import { plugin } from &quot;bun&quot;;
 41: import fooPlugin from &quot;bun-plugin-foo&quot;;
 42: 
 43: plugin(
 44:   fooPlugin({
 45:     // configuration
 46:   }),
 47: );
 48: ```
 49: 
 50: Bun&apos;s plugin API is loosely based on [esbuild](https://esbuild.github.io/plugins). Only [a subset](https://bun.sh/docs/bundler/vs-esbuild#plugin-api) of the esbuild API is implemented, but some esbuild plugins &quot;just work&quot; in Bun, like the official [MDX loader](https://mdxjs.com/packages/esbuild/):
 51: 
 52: ```jsx
 53: import { plugin } from &quot;bun&quot;;
 54: import mdx from &quot;@mdx-js/esbuild&quot;;
 55: 
 56: plugin(mdx());
 57: ```
 58: 
 59: ## Loaders
 60: 
 61: Plugins are primarily used to extend Bun with loaders for additional file types. Let&apos;s look at a simple plugin that implements a loader for `.yaml` files.
 62: 
 63: ```ts#yamlPlugin.ts
 64: import { plugin } from &quot;bun&quot;;
 65: 
 66: await plugin({
 67:   name: &quot;YAML&quot;,
 68:   async setup(build) {
 69:     const { load } = await import(&quot;js-yaml&quot;);
 70: 
 71:     // when a .yaml file is imported...
 72:     build.onLoad({ filter: /\.(yaml|yml)$/ }, async (args) =&gt; {
 73: 
 74:       // read and parse the file
 75:       const text = await Bun.file(args.path).text();
 76:       const exports = load(text) as Record&lt;string, any&gt;;
 77: 
 78:       // and returns it as a module
 79:       return {
 80:         exports,
 81:         loader: &quot;object&quot;, // special loader for JS objects
 82:       };
 83:     });
 84:   },
 85: });
 86: ```
 87: 
 88: Register this file in `preload`:
 89: 
 90: ```toml#bunfig.toml
 91: preload = [&quot;./yamlPlugin.ts&quot;]
 92: ```
 93: 
 94: Once the plugin is registered, `.yaml` and `.yml` files can be directly imported.
 95: 
 96: {% codetabs %}
 97: 
 98: ```ts#index.ts
 99: import data from &quot;./data.yml&quot;
100: 
101: console.log(data);
102: ```
103: 
104: ```yaml#data.yml
105: name: Fast X
106: releaseYear: 2023
107: ```
108: 
109: {% /codetabs %}
110: 
111: Note that the returned object has a `loader` property. This tells Bun which of its internal loaders should be used to handle the result. Even though we&apos;re implementing a loader for `.yaml`, the result must still be understandable by one of Bun&apos;s built-in loaders. It&apos;s loaders all the way down.
112: 
113: In this case we&apos;re using `&quot;object&quot;`a built-in loader (intended for use by plugins) that converts a plain JavaScript object to an equivalent ES module. Any of Bun&apos;s built-in loaders are supported; these same loaders are used by Bun internally for handling files of various kinds. The table below is a quick reference; refer to [Bundler &gt; Loaders](https://bun.sh/docs/bundler/loaders) for complete documentation.
114: 
115: {% table %}
116: 
117: - Loader
118: - Extensions
119: - Output
120: 
121: ---
122: 
123: - `js`
124: - `.mjs` `.cjs`
125: - Transpile to JavaScript files
126: 
127: ---
128: 
129: - `jsx`
130: - `.js` `.jsx`
131: - Transform JSX then transpile
132: 
133: ---
134: 
135: - `ts`
136: - `.ts` `.mts` `.cts`
137: - Transform TypeScript then transpile
138: 
139: ---
140: 
141: - `tsx`
142: - `.tsx`
143: - Transform TypeScript, JSX, then transpile
144: 
145: ---
146: 
147: - `toml`
148: - `.toml`
149: - Parse using Bun&apos;s built-in TOML parser
150: 
151: ---
152: 
153: - `json`
154: - `.json`
155: - Parse using Bun&apos;s built-in JSON parser
156: 
157: ---
158: 
159: - `napi`
160: - `.node`
161: - Import a native Node.js addon
162: 
163: ---
164: 
165: - `wasm`
166: - `.wasm`
167: - Import a native Node.js addon
168: 
169: ---
170: 
171: - `object`
172: - _none_
173: - A special loader intended for plugins that converts a plain JavaScript object to an equivalent ES module. Each key in the object corresponds to a named export.
174: 
175: {% /callout %}
176: 
177: Loading a YAML file is useful, but plugins support more than just data loading. Let&apos;s look at a plugin that lets Bun import `*.svelte` files.
178: 
179: ```ts#sveltePlugin.ts
180: import { plugin } from &quot;bun&quot;;
181: 
182: await plugin({
183:   name: &quot;svelte loader&quot;,
184:   async setup(build) {
185:     const { compile } = await import(&quot;svelte/compiler&quot;);
186: 
187:     // when a .svelte file is imported...
188:     build.onLoad({ filter: /\.svelte$/ }, async ({ path }) =&gt; {
189: 
190:       // read and compile it with the Svelte compiler
191:       const file = await Bun.file(path).text();
192:       const contents = compile(file, {
193:         filename: path,
194:         generate: &quot;ssr&quot;,
195:       }).js.code;
196: 
197:       // and return the compiled source code as &quot;js&quot;
198:       return {
199:         contents,
200:         loader: &quot;js&quot;,
201:       };
202:     });
203:   },
204: });
205: ```
206: 
207: &gt; Note: in a production implementation, you&apos;d want to cache the compiled output and include additional error handling.
208: 
209: The object returned from `build.onLoad` contains the compiled source code in `contents` and specifies `&quot;js&quot;` as its loader. That tells Bun to consider the returned `contents` to be a JavaScript module and transpile it using Bun&apos;s built-in `js` loader.
210: 
211: With this plugin, Svelte components can now be directly imported and consumed.
212: 
213: ```js
214: import &quot;./sveltePlugin.ts&quot;;
215: import MySvelteComponent from &quot;./component.svelte&quot;;
216: 
217: console.log(MySvelteComponent.render());
218: ```
219: 
220: ## Virtual Modules
221: 
222: {% note %}
223: 
224: This feature is currently only available at runtime with `Bun.plugin` and not yet supported in the bundler, but you can mimic the behavior using `onResolve` and `onLoad`.
225: 
226: {% /note %}
227: 
228: To create virtual modules at runtime, use `builder.module(specifier, callback)` in the `setup` function of a `Bun.plugin`.
229: 
230: For example:
231: 
232: ```js
233: import { plugin } from &quot;bun&quot;;
234: 
235: plugin({
236:   name: &quot;my-virtual-module&quot;,
237: 
238:   setup(build) {
239:     build.module(
240:       // The specifier, which can be any string - except a built-in, such as &quot;buffer&quot;
241:       &quot;my-transpiled-virtual-module&quot;,
242:       // The callback to run when the module is imported or required for the first time
243:       () =&gt; {
244:         return {
245:           contents: &quot;console.log(&apos;hello world!&apos;)&quot;,
246:           loader: &quot;js&quot;,
247:         };
248:       },
249:     );
250: 
251:     build.module(&quot;my-object-virtual-module&quot;, () =&gt; {
252:       return {
253:         exports: {
254:           foo: &quot;bar&quot;,
255:         },
256:         loader: &quot;object&quot;,
257:       };
258:     });
259:   },
260: });
261: 
262: // Sometime later
263: // All of these work
264: import &quot;my-transpiled-virtual-module&quot;;
265: require(&quot;my-transpiled-virtual-module&quot;);
266: await import(&quot;my-transpiled-virtual-module&quot;);
267: require.resolve(&quot;my-transpiled-virtual-module&quot;);
268: 
269: import { foo } from &quot;my-object-virtual-module&quot;;
270: const object = require(&quot;my-object-virtual-module&quot;);
271: await import(&quot;my-object-virtual-module&quot;);
272: require.resolve(&quot;my-object-virtual-module&quot;);
273: ```
274: 
275: ### Overriding existing modules
276: 
277: You can also override existing modules with `build.module`.
278: 
279: ```js
280: import { plugin } from &quot;bun&quot;;
281: build.module(&quot;my-object-virtual-module&quot;, () =&gt; {
282:   return {
283:     exports: {
284:       foo: &quot;bar&quot;,
285:     },
286:     loader: &quot;object&quot;,
287:   };
288: });
289: 
290: require(&quot;my-object-virtual-module&quot;); // { foo: &quot;bar&quot; }
291: await import(&quot;my-object-virtual-module&quot;); // { foo: &quot;bar&quot; }
292: 
293: build.module(&quot;my-object-virtual-module&quot;, () =&gt; {
294:   return {
295:     exports: {
296:       baz: &quot;quix&quot;,
297:     },
298:     loader: &quot;object&quot;,
299:   };
300: });
301: require(&quot;my-object-virtual-module&quot;); // { baz: &quot;quix&quot; }
302: await import(&quot;my-object-virtual-module&quot;); // { baz: &quot;quix&quot; }
303: ```
304: 
305: ## Reading or modifying the config
306: 
307: Plugins can read and write to the [build config](https://bun.sh/docs/bundler#api) with `build.config`.
308: 
309: ```ts
310: await Bun.build({
311:   entrypoints: [&quot;./app.ts&quot;],
312:   outdir: &quot;./dist&quot;,
313:   sourcemap: &quot;external&quot;,
314:   plugins: [
315:     {
316:       name: &quot;demo&quot;,
317:       setup(build) {
318:         console.log(build.config.sourcemap); // &quot;external&quot;
319: 
320:         build.config.minify = true; // enable minification
321: 
322:         // `plugins` is readonly
323:         console.log(`Number of plugins: ${build.config.plugins.length}`);
324:       },
325:     },
326:   ],
327: });
328: ```
329: 
330: {% callout %}
331: 
332: **NOTE**: Plugin lifcycle callbacks (`onStart()`, `onResolve()`, etc.) do not have the ability to modify the `build.config` object in the `setup()` function. If you want to mutate `build.config`, you must do so directly in the `setup()` function:
333: 
334: ```ts
335: await Bun.build({
336:   entrypoints: [&quot;./app.ts&quot;],
337:   outdir: &quot;./dist&quot;,
338:   sourcemap: &quot;external&quot;,
339:   plugins: [
340:     {
341:       name: &quot;demo&quot;,
342:       setup(build) {
343:         //  good! modifying it directly in the setup() function
344:         build.config.minify = true;
345: 
346:         build.onStart(() =&gt; {
347:           //  uh-oh! this won&apos;t work!
348:           build.config.minify = false;
349:         });
350:       },
351:     },
352:   ],
353: });
354: ```
355: 
356: {% /callout %}
357: 
358: ## Lifecycle hooks
359: 
360: Plugins can register callbacks to be run at various points in the lifecycle of a bundle:
361: 
362: - [`onStart()`](#onstart): Run once the bundler has started a bundle
363: - [`onResolve()`](#onresolve): Run before a module is resolved
364: - [`onLoad()`](#onload): Run before a module is loaded.
365: 
366: ### Reference
367: 
368: A rough overview of the types (please refer to Bun&apos;s `bun.d.ts` for the full type definitions):
369: 
370: ```ts
371: namespace Bun {
372:   function plugin(plugin: {
373:     name: string;
374:     setup: (build: PluginBuilder) =&gt; void;
375:   }): void;
376: }
377: 
378: type PluginBuilder = {
379:   onStart(callback: () =&gt; void): void;
380:   onResolve: (
381:     args: { filter: RegExp; namespace?: string },
382:     callback: (args: { path: string; importer: string }) =&gt; {
383:       path: string;
384:       namespace?: string;
385:     } | void,
386:   ) =&gt; void;
387:   onLoad: (
388:     args: { filter: RegExp; namespace?: string },
389:     callback: (args: { path: string }) =&gt; {
390:       loader?: Loader;
391:       contents?: string;
392:       exports?: Record&lt;string, any&gt;;
393:     },
394:   ) =&gt; void;
395:   config: BuildConfig;
396: };
397: 
398: type Loader = &quot;js&quot; | &quot;jsx&quot; | &quot;ts&quot; | &quot;tsx&quot; | &quot;css&quot; | &quot;json&quot; | &quot;toml&quot; | &quot;object&quot;;
399: ```
400: 
401: ### Namespaces
402: 
403: `onLoad` and `onResolve` accept an optional `namespace` string. What is a namespaace?
404: 
405: Every module has a namespace. Namespaces are used to prefix the import in transpiled code; for instance, a loader with a `filter: /\.yaml$/` and `namespace: &quot;yaml:&quot;` will transform an import from `./myfile.yaml` into `yaml:./myfile.yaml`.
406: 
407: The default namespace is `&quot;file&quot;` and it is not necessary to specify it, for instance: `import myModule from &quot;./my-module.ts&quot;` is the same as `import myModule from &quot;file:./my-module.ts&quot;`.
408: 
409: Other common namespaces are:
410: 
411: - `&quot;bun&quot;`: for Bun-specific modules (e.g. `&quot;bun:test&quot;`, `&quot;bun:sqlite&quot;`)
412: - `&quot;node&quot;`: for Node.js modules (e.g. `&quot;node:fs&quot;`, `&quot;node:path&quot;`)
413: 
414: ### `onStart`
415: 
416: ```ts
417: onStart(callback: () =&gt; void): Promise&lt;void&gt; | void;
418: ```
419: 
420: Registers a callback to be run when the bundler starts a new bundle.
421: 
422: ```ts
423: import { plugin } from &quot;bun&quot;;
424: 
425: plugin({
426:   name: &quot;onStart example&quot;,
427: 
428:   setup(build) {
429:     build.onStart(() =&gt; {
430:       console.log(&quot;Bundle started!&quot;);
431:     });
432:   },
433: });
434: ```
435: 
436: The callback can return a `Promise`. After the bundle process has initialized, the bundler waits until all `onStart()` callbacks have completed before continuing.
437: 
438: For example:
439: 
440: ```ts
441: const result = await Bun.build({
442:   entrypoints: [&quot;./app.ts&quot;],
443:   outdir: &quot;./dist&quot;,
444:   sourcemap: &quot;external&quot;,
445:   plugins: [
446:     {
447:       name: &quot;Sleep for 10 seconds&quot;,
448:       setup(build) {
449:         build.onStart(async () =&gt; {
450:           await Bunlog.sleep(10_000);
451:         });
452:       },
453:     },
454:     {
455:       name: &quot;Log bundle time to a file&quot;,
456:       setup(build) {
457:         build.onStart(async () =&gt; {
458:           const now = Date.now();
459:           await Bun.$`echo ${now} &gt; bundle-time.txt`;
460:         });
461:       },
462:     },
463:   ],
464: });
465: ```
466: 
467: In the above example, Bun will wait until the first `onStart()` (sleeping for 10 seconds) has completed, _as well as_ the second `onStart()` (writing the bundle time to a file).
468: 
469: Note that `onStart()` callbacks (like every other lifecycle callback) do not have the ability to modify the `build.config` object. If you want to mutate `build.config`, you must do so directly in the `setup()` function.
470: 
471: ### `onResolve`
472: 
473: ```ts
474: onResolve(
475:   args: { filter: RegExp; namespace?: string },
476:   callback: (args: { path: string; importer: string }) =&gt; {
477:     path: string;
478:     namespace?: string;
479:   } | void,
480: ): void;
481: ```
482: 
483: To bundle your project, Bun walks down the dependency tree of all modules in your project. For each imported module, Bun actually has to find and read that module. The &quot;finding&quot; part is known as &quot;resolving&quot; a module.
484: 
485: The `onResolve()` plugin lifecycle callback allows you to configure how a module is resolved.
486: 
487: The first argument to `onResolve()` is an object with a `filter` and [`namespace`](#what-is-a-namespace) property. The filter is a regular expression which is run on the import string. Effectively, these allow you to filter which modules your custom resolution logic will apply to.
488: 
489: The second argument to `onResolve()` is a callback which is run for each module import Bun finds that matches the `filter` and `namespace` defined in the first argument.
490: 
491: The callback receives as input the _path_ to the matching module. The callback can return a _new path_ for the module. Bun will read the contents of the _new path_ and parse it as a module.
492: 
493: For example, redirecting all imports to `images/` to `./public/images/`:
494: 
495: ```ts
496: import { plugin } from &quot;bun&quot;;
497: 
498: plugin({
499:   name: &quot;onResolve example&quot;,
500:   setup(build) {
501:     build.onResolve({ filter: /.*/, namespace: &quot;file&quot; }, args =&gt; {
502:       if (args.path.startsWith(&quot;images/&quot;)) {
503:         return {
504:           path: args.path.replace(&quot;images/&quot;, &quot;./public/images/&quot;),
505:         };
506:       }
507:     });
508:   },
509: });
510: ```
511: 
512: ### `onLoad`
513: 
514: ```ts
515: onLoad(
516:   args: { filter: RegExp; namespace?: string },
517:   callback: (args: { path: string, importer: string, namespace: string, kind: ImportKind  }) =&gt; {
518:     loader?: Loader;
519:     contents?: string;
520:     exports?: Record&lt;string, any&gt;;
521:   },
522: ): void;
523: ```
524: 
525: After Bun&apos;s bundler has resolved a module, it needs to read the contents of the module and parse it.
526: 
527: The `onLoad()` plugin lifecycle callback allows you to modify the _contents_ of a module before it is read and parsed by Bun.
528: 
529: Like `onResolve()`, the first argument to `onLoad()` allows you to filter which modules this invocation of `onLoad()` will apply to.
530: 
531: The second argument to `onLoad()` is a callback which is run for each matching module _before_ Bun loads the contents of the module into memory.
532: 
533: This callback receives as input the _path_ to the matching module, the _importer_ of the module (the module that imported the module), the _namespace_ of the module, and the _kind_ of the module.
534: 
535: The callback can return a new `contents` string for the module as well as a new `loader`.
536: 
537: For example:
538: 
539: ```ts
540: import { plugin } from &quot;bun&quot;;
541: 
542: plugin({
543:   name: &quot;env plugin&quot;,
544:   setup(build) {
545:     build.onLoad({ filter: /env/, namespace: &quot;file&quot; }, args =&gt; {
546:       return {
547:         contents: `export default ${JSON.stringify(process.env)}`,
548:         loader: &quot;js&quot;,
549:       };
550:     });
551:   },
552: });
553: ```
554: 
555: This plugin will transform all imports of the form `import env from &quot;env&quot;` into a JavaScript module that exports the current environment variables.</file><file path="packages/docs/bun/workspaces.md"> 1: Bun supports [`workspaces`](https://docs.npmjs.com/cli/v9/using-npm/workspaces?v=true#description) in `package.json`. Workspaces make it easy to develop complex software as a _monorepo_ consisting of several independent packages.
 2: 
 3: It&apos;s common for a monorepo to have the following structure:
 4: 
 5: ```
 6: tree
 7: &lt;root&gt;
 8:  README.md
 9:  bun.lock
10:  package.json
11:  tsconfig.json
12:  packages
13:      pkg-a
14:         index.ts
15:         package.json
16:         tsconfig.json
17:      pkg-b
18:         index.ts
19:         package.json
20:         tsconfig.json
21:      pkg-c
22:          index.ts
23:          package.json
24:          tsconfig.json
25: ```
26: 
27: In the root `package.json`, the `&quot;workspaces&quot;` key is used to indicate which subdirectories should be considered packages/workspaces within the monorepo. It&apos;s conventional to place all the workspace in a directory called `packages`.
28: 
29: ```json
30: {
31:   &quot;name&quot;: &quot;my-project&quot;,
32:   &quot;version&quot;: &quot;1.0.0&quot;,
33:   &quot;workspaces&quot;: [&quot;packages/*&quot;],
34:   &quot;devDependencies&quot;: {
35:     &quot;example-package-in-monorepo&quot;: &quot;workspace:*&quot;
36:   }
37: }
38: ```
39: 
40: {% callout %}
41: **Glob support**  Bun supports full glob syntax in `&quot;workspaces&quot;` (see [here](https://bun.sh/docs/api/glob#supported-glob-patterns) for a comprehensive list of supported syntax), _except_ for exclusions (e.g. `!**/excluded/**`), which are not implemented yet.
42: {% /callout %}
43: 
44: Each workspace has it&apos;s own `package.json`. When referencing other packages in the monorepo, semver or workspace protocols (e.g. `workspace:*`) can be used as the version field in your `package.json`.
45: 
46: ```json
47: {
48:   &quot;name&quot;: &quot;pkg-a&quot;,
49:   &quot;version&quot;: &quot;1.0.0&quot;,
50:   &quot;dependencies&quot;: {
51:     &quot;pkg-b&quot;: &quot;workspace:*&quot;
52:   }
53: }
54: ```
55: 
56: `bun install` will install dependencies for all workspaces in the monorepo, de-duplicating packages if possible. If you only want to install dependencies for specific workspaces, you can use the `--filter` flag.
57: 
58: ```bash
59: # Install dependencies for all workspaces starting with `pkg-` except for `pkg-c`
60: $ bun install --filter &quot;pkg-*&quot; --filter &quot;!pkg-c&quot;
61: 
62: # Paths can also be used. This is equivalent to the command above.
63: $ bun install --filter &quot;./packages/pkg-*&quot; --filter &quot;!pkg-c&quot; # or --filter &quot;!./packages/pkg-c&quot;
64: ```
65: 
66: Workspaces have a couple major benefits.
67: 
68: - **Code can be split into logical parts.** If one package relies on another, you can simply add it as a dependency in `package.json`. If package `b` depends on `a`, `bun install` will install your local `packages/a` directory into `node_modules` instead of downloading it from the npm registry.
69: - **Dependencies can be de-duplicated.** If `a` and `b` share a common dependency, it will be _hoisted_ to the root `node_modules` directory. This reduces redundant disk usage and minimizes &quot;dependency hell&quot; issues associated with having multiple versions of a package installed simultaneously.
70: - **Run scripts in multiple packages.** You can use the [`--filter` flag](https://bun.sh/docs/cli/filter) to easily run `package.json` scripts in multiple packages in your workspace.
71: 
72: {% callout %}
73:  **Speed**  Installs are fast, even for big monorepos. Bun installs the [Remix](https://github.com/remix-run/remix) monorepo in about `500ms` on Linux.
74: 
75: - 28x faster than `npm install`
76: - 12x faster than `yarn install` (v1)
77: - 8x faster than `pnpm install`
78: 
79: {% image src=&quot;https://user-images.githubusercontent.com/709451/212829600-77df9544-7c9f-4d8d-a984-b2cd0fd2aa52.png&quot; /%}
80: {% /callout %}</file><file path="packages/docs/gemini/example.ts">  1: import {
  2:     GoogleGenerativeAI,
  3: } from &quot;@google/generative-ai&quot;;
  4: import { GoogleAIFileManager } from &quot;@google/generative-ai/server&quot;;
  5: 
  6: const apiKey = process.env.GEMINI_API_KEY as string;
  7:   const genAI = new GoogleGenerativeAI(apiKey);
  8:   const fileManager = new GoogleAIFileManager(apiKey);
  9:   
 10:   /**
 11:    * Uploads the given file to Gemini.
 12:    *
 13:    * See https://ai.google.dev/gemini-api/docs/prompting_with_media
 14:    */
 15:   async function uploadToGemini(path, mimeType) {
 16:     const uploadResult = await fileManager.uploadFile(path, {
 17:   async function uploadToGemini(path: string, mimeType: string) {
 18:       displayName: path,
 19:     });
 20:     const file = uploadResult.file;
 21:     console.log(`Uploaded file ${file.displayName} as: ${file.name}`);
 22:     return file;
 23:   }
 24:   
 25:   /**
 26:    * Waits for the given files to be active.
 27:    *
 28:    * Some files uploaded to the Gemini API need to be processed before they can
 29:    * be used as prompt inputs. The status can be seen by querying the file&apos;s
 30:    * &quot;state&quot; field.
 31:    *
 32:    * This implementation uses a simple blocking polling loop. Production code
 33:    * should probably employ a more sophisticated approach.
 34:    */
 35:   async function waitForFilesActive(files) {
 36:     console.log(&quot;Waiting for file processing...&quot;);
 37:   async function waitForFilesActive(files: any[]) {
 38:       let file = await fileManager.getFile(name);
 39:     for (const name of files.map((file: any) =&gt; file.name)) {
 40:         process.stdout.write(&quot;.&quot;)
 41:         await new Promise((resolve) =&gt; setTimeout(resolve, 10_000));
 42:         file = await fileManager.getFile(name)
 43:       }
 44:       if (file.state !== &quot;ACTIVE&quot;) {
 45:         throw Error(`File ${file.name} failed to process`);
 46:       }
 47:     }
 48:     console.log(&quot;...all files ready\n&quot;);
 49:   }
 50:   
 51:   const model = genAI.getGenerativeModel({
 52:     model: &quot;gemini-2.0-flash-lite-preview-02-05&quot;,
 53:     tools: [
 54:       {
 55:         functionDeclarations: [
 56:           {
 57:             name: &quot;get zsh script&quot;,
 58:             description: &quot;given a task, output a shell script that implements it interactivly&quot;
 59:           }
 60:         ]
 61:       }
 62:     ],
 63:     toolConfig: {functionCallingConfig: {mode: &quot;ANY&quot;}},
 64:   });
 65:   
 66:   const generationConfig = {
 67:     temperature: 1,
 68:     topP: 0.95,
 69:     topK: 64,
 70:     maxOutputTokens: 8192,
 71:     responseMimeType: &quot;text/plain&quot;,
 72:   };
 73:   
 74:   async function run() {
 75:     // TODO Make these files available on the local file system
 76:     // You may need to update the file paths
 77:     const files = [
 78:       await uploadToGemini(&quot;shell.md&quot;, &quot;text/markdown&quot;),
 79:     ];
 80:   
 81:     // Some files have a processing delay. Wait for them to be ready.
 82:     await waitForFilesActive(files);
 83:   
 84:     const chatSession = model.startChat({
 85:       generationConfig,
 86:       history: [
 87:         {
 88:           role: &quot;user&quot;,
 89:           parts: [
 90:             {
 91:               fileData: {
 92:                 mimeType: files[0].mimeType,
 93:                 fileUri: files[0].uri,
 94:               },
 95:             },
 96:           ],
 97:         },
 98:       ],
 99:     });
100:   
101:     const result = await chatSession.sendMessage(&quot;INSERT_INPUT_HERE&quot;);
102:     for(candidate of result.response.candidates) {
103:       for(part of candidate.content.parts) {
104:     for(const candidate of result.response.candidates) {
105:       for(const part of candidate.content.parts) {
106:           const args = Object
107:             .keys(items)
108:             .map((data) =&gt; [data, items[data]])
109:             .map(([key, value]) =&gt; `${key}:${value}`)
110:             .join(&apos;, &apos;);
111:           console.log(`${part.functionCall.name}(${args})`);
112:         }
113:       }
114:     }
115:   }
116:   
117:   run();</file><file path="packages/docs/gemini/models.md">1: nidumai/nidum-llama-3.2-3b-uncensored
2: brianmatzelle/llama3.1-8b-instruct-hasanpiker-abliterated</file><file path="packages/docs/ronin/LanguageX.md">  1: create a new programming langague called `Language X` that is close to pseudo code and has minimal boilerplate, python is a greate example, but don&apos;t use all of python&apos;s syntax, javascript is also a good example, but let&apos;s mix and match different syntrax to get the most easy language to write mixing all the good features of every one and avoid any of the extra stuff that comes with tradiational programming languages;
  2: the programming language will also implement types and for that we will use the typescript typing syntax;
  3: This langugae is designed for developers to make prompt engineering easier by using this programming language to prompt the chat model.
  4: Both the model and the user must agree on the language syntax for common and basic programming features, like looping, logging to the console.
  5: 
  6: # Function declration
  7: 
  8: ```x
  9: // Function do not have a body, function declration are only written in the below syntax and should never include a body!
 10: // Function names must always start with a verb e.g `add` or `get` or `set` or `delete` etc... and must me camelCased
 11: func getRandomNumber () =&gt; $randomNumber: number // returns a random number
 12: func addTwoNumbers ($x: number, $y: number) =&gt; $sum: number // returns the sum of $x and $y
 13: ```
 14: 
 15: # Variables
 16: 
 17: ```x
 18: // Can be either delcared using const or let
 19: const sum: number = addTwoNumbers(2, 3) // $sum is equal to 5
 20: // But to reference a variable you have to use $ as a prfix:
 21: const newSum = addTwoNumbers($sum, 1) // $newSum is equal to 6
 22: ```
 23: 
 24: # Using functions from other programming language:
 25: 
 26: ```x
 27: // Built-functions of other language are supported as long they only deal with primitive values which are either strings, numbers or booleans.
 28: // It also supports arrays, but they have to be arrays of primitive values, e.g array of strings, numbers or booleans
 29: // To use the .sort() function from javascript:
 30: ```
 31: 
 32: ```x
 33: const unsortedList = [3, 1, 1]
 34: const list = js:sort($unsortedList) // this clones $unsortedList into $list and then sorts $list
 35: // this is equivalnt to:
 36: func sort($list: array) =&gt; $sortedList: array // returns a sorted clone of $list
 37: // but the addition of `js:` implies that the default javascript sorting algorithm should be used to sort these elements and this will also be used by transpilers / interperters to generate code using javascript for this line
 38: ```
 39: 
 40: # Immutability
 41: 
 42: In `Language X` all functions must return a value, it is a purely functional programming language where there is no concept of objects or oop, and as such it should be assumed that all functions imported from another language will not modify variables in place and will instead clone their arguments and create a new reference in memory
 43: 
 44: ```x
 45: // using different variants of the same function e.g `Array.sort()` and `Array.toSorted()` does not have any effect and the result is still the same, the only difference is the naming
 46: const list = js:toSorted([3, 2, 1])
 47: ```
 48: 
 49: # Some common functions
 50: 
 51: ```x
 52: // valid code
 53: const list = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
 54: const listLength = py:len($list) // $listLength is equal to 3
 55: ```
 56: 
 57: ```x
 58: // invalid code !
 59: const list = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
 60: const listLength = list.length // error! LanguageX does not support any form dot notation or object access modifiers
 61: // You may however use indices to get elements of an array:
 62: const list = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
 63: const firstElement = $list[0] // if list[0] is empty accessing elements this way will produce an error!
 64: ```
 65: 
 66: # Loops
 67: 
 68: there is only one type of loop in `X` which is the for do loop:
 69: 
 70: ```x
 71: for $elem in $list
 72:     do `sh:echo $elem` // prints $elem to stdout
 73: ```
 74: 
 75: multiple do statement:
 76: 
 77: ```x
 78: for $elem in $list
 79:     do `const planet = &apos;earth&apos;`
 80:     do `sh:echo $elem + $planet` // prints $elem + $plant (string aggregation)
 81: ```
 82: 
 83: With loop variable:
 84: 
 85: ```x
 86: const _ = py:range(0, 5)
 87: for $index in _
 88:     do `echo $index` // outputs 0, 1, 2, 3, 4
 89: ```
 90: 
 91: # AI
 92: 
 93: A special syntax may be used to instruct llms to generate values dynamcilly to be used in the script.
 94: 
 95: ```x
 96: sh:echo({{ string: a random joke }}) // when an llm sees this it should substitute what&apos;s between the `{{` and the `}}` with the prompt inside it.
 97: // so an llm should read the above line as `sh:echo &lt;a string of a random hoke&gt;.
 98: ```
 99: 
100: You may also assign varibles using this syntax:
101: 
102: ```x
103: const randomHumanName = {{ string: random name of a human}};
104: // in which case randomHumanName&apos;s value is generated by the llm and then put back into the source file.
105: ```
106: 
107: # Asynchronous Programming
108: 
109: async/await is not supported in `X`. To write asynchrounous code you can use the following syntax:
110: 
111: ```x
112: func[4] fetchWeatherData($country: string) =&gt; &lt;$weatherData: string[]&gt; // fetches $weatherData from th server filtered by $country
113: // the number 4` here indicates the max time a single network request should take. and a TIMEOUT error is thrown if the request didn&apos;t complete within 4 seconds of the request. This is handled internally by using the Promise.race() javascript function `js:race` ,`4` seconds is usually a very big timeout if you are just fetching json data from the server as it usually takes milliseconds to send/receive hunbders of enteries beteween client and server.
114: when the return of a function is put between `&lt;` and `&gt;` this marks the variable as asynchronus and it resolves to a Response object.
115: A docker proxy server running in the middle of the client and the server handles incoming requests from the client and responses from the server.
116: actint as a controller, this proxy server also uses ssh keys to encrypy and decrypt data between server and client in secure way.
117: The proxy server also handle convertion of `Response` objects coming from the server to JSON.parse({body of the response}).
118: meaning it only extracts a plain javascript object (that can be represented in json) and sends it to the client. and does the reverse for the client. when the client sends a Request objects to the server, the proxy server also extracts a plain javascript object from the response that is usually the body of the request and forwards it to the main server.
119: communication between the client - proxy server - main server is secured using ssh keys and digital signatures.
120: but sometimes if you are uploading a file or an image the request may take longer in that case you can mark the function as infinite:
121: func[] postImageFiles(files: string[]) =&gt; response: Response // Native `Response` inteface for both node and browser
122: ```
123: 
124: ````x
125: //you can also use the string `infinity` instead.
126: func[infinity] keepFetchingUntilServerTimesout() =&gt; &lt;void&gt;;
127: 
128: 
129: # Await
130: ```x
131: // the `use` operator is equivalnt to `await`, however it will validate the data against the async function&apos;s return type using zod schemas and if the type does not match a validation error will be thrown!
132: const data = use fetchWeatherData(&apos;New Zealend&apos;)
133: // At this point data is validated and awaited and the `data` variable is a list of string.
134: for $elem in $data
135:     do `sh:echo $elem` // outputs 23, 32, 23, etc..
136: ````
137: 
138: # Database operations
139: 
140: The `Database` in `LanguageX` is a key-value documents database stored as josn.
141: There are TWO databased in `X`.
142: The first one is the server based database and the second one is the client side database.
143: And then there is a `shadow` database that can be used to store shared database key/values pairs.
144: This `shadow` database is initialized on the server, populated with keys that the server wants to share with the client. On first client load; the `shadow` database is sent to the client as cookies. This is also a two-way data sharing mechanism; by making the server send extra shared keys with no value to the client, (like the server send the client a key called `userName` with no value), this allows the client to set the value by itself using a POST request to the server with the value for the key.
145: The server then has control whether to sync that change on the server.
146: Once the server has decieded what to do with the received data in the post request, it sends the user a hash of the value it received. This hash is generated by using the user&apos;s public ssh key to digitally sign the data.
147: All POST requests from the client to the server must include a `userId` in the body of the request.
148: The value of `userId` is treated as the public ssh key of the user and is used to digitally sign data sent from the server to the client.
149: Respectivly, all responses from POST request include the `serverId` key/value pair in the response body. This `serverId` is treated as the server&apos;s public ssh key.
150: The user uses client side authentication methods to generate both a private and a public ssh key.
151: The user&apos;s private ssh key is generated by any authentication method preferabbable as long as it generated both a private and a publick ssh key.
152: Once the private key is generated on the client, it is turned into a hash using the server&apos;s publick ssh key `serverId` which can be found by making a GET request to `/handshake/id` which returns the key as raw text.
153: After the client users `serverId` to turn their private ssh key into a hash, they delete the private key from the client and send the generated hash to the server.
154: The client then either asks the user for a `password` that will be used to encrypt the hash or use a JWT token or biometric authentication or single-sign-onn sso.
155: 
156: ```x
157: // ! Example workflow:
158: func[3.5] postData($data: string[], $url: string) =&gt; &lt;$response:Response&gt; e // The native Javascript V8 `Response` interface. or throws a timeout error after 3.5 seconds.
159: 
160: ```
161: 
162: # Conditionals and optional chaining
163: 
164: ```x
165: // You can use if statements in `X`
166: const data = postData([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], &quot;/test&quot;)
167: // the `use` operator automacilly returns the validated response body data against zod schemas, which means you get intellisense if you have setup your zod schemas.
168: // the `use` operator also &apos;await&apos; the data
169: const validatedData = use $data
170: // you can now access properties on the validated data. however properties are stored as arrays and not obects!
171: // for example:
172: const someObject = {someProp: &apos;someValue&apos;} // ! invalid
173: instead data is validated and returned as a matrix.
174: It mimics a sqllite structure tables;
175: ```
176: 
177: # Database Structure
178: 
179: Data in `X` is stored as a matrix (2D array). The first array contains the schema, and subsequent arrays contain the actual data.
180: 
181: ```x
182: // Example database structure
183: const db = [
184:     // Schema definition
185:     [
186:         [&quot;id&quot;, [
187:             [&quot;type&quot;, &quot;number&quot;],
188:             [&quot;@unique&quot;, true],
189:             [&quot;@id&quot;, true]
190:         ]],
191:         [&quot;name&quot;, [
192:             [&quot;type&quot;, &quot;string&quot;],
193:             [&quot;@unique&quot;, true],
194:             [&quot;@id&quot;, false]
195:         ]],
196:         [&quot;email&quot;, [
197:             [&quot;type&quot;, &quot;string&quot;],
198:             [&quot;@unique&quot;, true],
199:             [&quot;@id&quot;, false]
200:         ]]
201:     ],
202:     // Data rows
203:     [1, &quot;John&quot;, &quot;john@email.com&quot;],
204:     [2, &quot;Alice&quot;, &quot;alice@email.com&quot;],
205:     [3, &quot;Bob&quot;, &quot;bob@email.com&quot;]
206: ]
207: 
208: // Accessing data
209: const firstRow = $db[1] // Returns [1, &quot;John&quot;, &quot;john@email.com&quot;]
210: const johnName = $db[1][1] // Returns &quot;John&quot;
211: ```
212: 
213: This structure allows for type safety and schema validation while keeping the data format simple and efficient.
214: 
215: # ORM
216: 
217: `X` comes with its own ORM that can integrate with any database.
218: `Prisma` or `lowdb` or `mainfest.js` or even just a local dev.db file with a sqlite3 database.
219: 
220: ## Usage:
221: 
222: // generates code to interact with prisma
223: // needs exporting of enviroment varibles to work correctly
224: // you will need to setup a .env file with keys like:
225: // = PRISMA_ROOT_FOLDER=&quot;./prisma
226: // - PRISMA_SCHEMA_PATH=&quot;./prisma/prisma.schema.ts&quot;
227: // - ... and some more (check prisma docks)
228: // the generated code uses `process.env[key]` to read enviroment varibles.
229: // .env files are loaded by default and made accessible to prisma.
230: const dataPromise = prisma[4]:getData() // max 4 seconds
231: const data = use dataPromise // data fetched and validated
232: 
233: # Other ORMs
234: 
235: YOu can also other ORMs lke Drizzle... etc.
236: you can also use either deno or bun for the runtime.
237: you can use bun or deno special features together in the same app wiwthout having to switch or change anything. everhting is avalaible with zero config.
238: 
239: ## So you can run
240: 
241: ```x
242: LanguageX does NOT use objects of any kind, but since array is actually an object in some language like javascript you can still emulate oop behavior, however that is very discourged and the prefered way is to use array string only.
243: This format unifies server and client communication
244: 
245: type Cat = [
246:     [string, string], // schema row: column names
247:     [string, string], // schema row: types
248:     ...[string, number][] // data rows
249: ]
250: ```
251: 
252: ```x
253: const catsPromise = bun:sql[20](&apos;SELECT \* FROM cats&apos;)
254: const cats : Cat[]= use catsPromise // now you have intellesense
255: js:log(js:stringfy(cats))
256: // outputs:
257: [
258: [[&quot;name&quot;, &quot;age&quot;],
259: [&quot;string&quot;, &quot;number&quot;]],
260: [&quot;Whiskers&quot;, 3],
261: [&quot;Luna&quot;, 2],
262: [&quot;Shadow&quot;, 4],
263: [&quot;Milo&quot;, 1],
264: [&quot;Bella&quot;, 5]
265: ]
266: 
267: ```
268: 
269: # Proxy Server
270: 
271: Communicatin between client and server are managed by the proxy server.
272: the proxy server is a private server owned by you (can even be your own laptop) that sits between the server and the client.
273: It has an admin panel that lets you configure and manage both client and server at the same time.
274: 
275: and as such this server should be kept private and limits access to certain users only (can be a docker image as well) (you can deploy bun server or deno servers or vercel).
276: 
277: the proxy server admin panel has the followig settings and methods: - toggle proxy server on/off - toggle demo mode on/off - switch themems - add CMS content - generate zod schemas script - validate script - setup request/response maps (or use trpc/grpc)
278: 
279: The proxy server is a monorepo that has several packages: - endpoints - generate - validate - generatedData - index.ts
280: It uses nx monorepo under the hood.
281: 
282: ## endpoints
283: 
284: type defiintions and configuration of api endpoints, this is required if you are going to use the proxy server.
285: for each url or &apos;endpoint&apos; in your api you should add an endpoint object that has the type `AppEndpoint` exported by the `endpoints` package.
286: `AppEndpoint` consists of many properties, as an example:
287: 
288: const testEndpoint = [
289: // Schema definition
290: [&quot;url&quot;, &quot;/api/test&quot;],
291: [&quot;method&quot;, &quot;POST&quot;],
292: [&quot;requestSchema&quot;, [
293: [&quot;status&quot;, &quot;string&quot;],
294: [&quot;message&quot;, &quot;string&quot;]
295: ]],
296: [&quot;responseSchema&quot;, [
297: [&quot;success&quot;, &quot;boolean&quot;],
298: [&quot;data&quot;, &quot;string[]&quot;]
299: ]],
300: [&quot;exampleRequest&quot;, [
301: &quot;ok&quot;,
302: &quot;test message&quot;
303: ]],
304: [&quot;exampleResponse&quot;, [
305: true,
306: [&quot;data1&quot;, &quot;data2&quot;]
307: ]]
308: ]
309: const testEndpoint = [
310: [&quot;url&quot;, &quot;requestSchema&quot;, &quot;exampleRequestBody&quot;],
311: [&quot;string&apos;, &quot;ZodTypeAny&quot;, &quot;z.infer&lt;typeof requestSchema&gt;]],
312: [&quot;/ap/test&quot;, &quot;[[&quot;status&quot;], [&quot;string&quot;], [&apos;ok]]&quot;, [[&apos;status&quot;], &quot;string&quot;,], [&quot;ok]]
313: 
314: ## generate
315: 
316: this scrirpt calls all endpoints defined in the `endpoints` package using the `exampleRequestBody` and a post request.
317: It then stores the response in an example-{endpoint}-{operation}.json file.
318: using the json file and a library called `json-to-zod` it generated zod schemas based on the response of each endpoint.
319: then it copies the fetched json file to the root of the package `generatedData`&apos;s `responseSchemas` folder.
320: the command sets up all schemas with import/export statement and uses the name defined in your `endpoints` package to generate the zod schema names.
321: 
322: Cross-origin-policy is restriected both on the client and the server and the proxy so only allowed domain on all three components of the app have the same cross-origin-policy the proxy server will be disabled and you will have to setup a backend yourself (maybe vercel)
323: 
324: once the resposneSchemas are genereated. you have to manually edit the root inde.ts file of the proxy server to export the newly generated endpoint.
325: 
326: # Server Actions with Next.js
327: 
328: For Next.js v15 with server actions, there is a global helper function:
329: 
330: ```x
331: // Helper function for form actions
332: func getFormAction($endpoint: URL, $method: string) =&gt; $action: FormFunction
333: // where method is one of: &quot;list&quot; | &quot;details&quot; | &quot;create&quot; | &quot;delete&quot; | &quot;update&quot;
334: // returns a function that handles form data submission
335: 
336: // Example usage:
337: const submitHandler = getFormAction(&quot;/api/users&quot;, &quot;create&quot;)
338: ```
339: 
340: The returned action function handles:
341: 
342: - Form data validation
343: - Request/response type safety
344: - Error handling
345: - Loading states
346: 
347: Usage in Next.js components:
348: 
349: ```x
350: // In a Next.js component
351: const form = getFormAction(&quot;/api/posts&quot;, &quot;create&quot;)
352: do `&lt;form action={$form}&gt;
353:     &lt;input name=&quot;title&quot; /&gt;
354:     &lt;button type=&quot;submit&quot;&gt;Create&lt;/button&gt;
355: &lt;/form&gt;`
356: //If you want to use Next.js v15 with server actions you have a helper function that is globally defined but here it is anyways:
357: func getFormAction(endpoint: URL, method: &quot;list&quot; | &quot;details&quot; | &quot;create&quot; | &quot;delete&quot; | update ) =&gt; (formData: FormData) =&gt; {}
358: ```
359: 
360: # How does mixing programming languages work?
361: 
362: in LanguageX you can import and use function from different programming language like rust, javascript and python.
363: how does that work?
364: well, the proxy server has access to a sandboxes docker container that has most programming language installed including ruby!
365: then when the interpeter encouters a line like:
366: 
367: ```x
368: js:log(&apos;hello workd&apos;)
369: ```
370: 
371: it runs a `docker exec` command to execute the javascript code using the node installation in the container.
372: sample command to run the above code inside the container will look like:
373: 
374: ```sh
375: docker exec lang-x-container node -e &quot;console.log(&apos;hello world&apos;)&quot;
376: ```
377: 
378: and it does the same for all languages, piping your input into the native function of the programming language and then extracting the output to the global frame.
379: 
380: # Userful Functions
381: 
382: ## getFormAction() =&gt; (formData: FormData) =&gt; [[&quot;id&quot;, &quot;name&quot;],[&quot;number&quot;, &quot;string&quot;]]
383: 
384: Used to handle form submissions in Next.js server actions:
385: 
386: ```x
387: // Create form handler
388: const submitHandler = getFormAction(&quot;/api/users&quot;, &quot;create&quot;)
389: 
390: // Handles:
391: - Form validation
392: - Type safety
393: - Error states  
394: - Loading states
395: ```
396: 
397: Example usage:
398: 
399: ```x
400: // In Next.js component
401: const form = getFormAction(&quot;/api/posts&quot;, &quot;create&quot;) 
402: do `&lt;form action={$form}&gt;
403:     &lt;input name=&quot;title&quot; /&gt;
404:     &lt;button&gt;Submit&lt;/button&gt;
405: &lt;/form&gt;`
406: ```
407: 
408: ## getFormAction() =&gt; (formData: FormData) =&gt; [[&quot;id&quot;, &quot;name&quot;],[&quot;number&quot;, &quot;string] ]
409: 
410: Check `packages/actions/server/getFormAction.ts`</file><file path="packages/docs/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/docs&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 8:     &quot;bun-types&quot;: &quot;latest&quot;,
 9:     &quot;zod&quot;: &quot;1&quot;
10:     
11:   }
12: }</file><file path="packages/hooks/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/hooks&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 8:     &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 9:     &quot;bun-types&quot;: &quot;latest&quot;,
10:     &quot;zod&quot;: &quot;1&quot;
11:   }
12: }</file><file path="packages/hooks/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;esnext&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path="packages/hooks/useFormAction.ts">  1: import { allEndpoints } from &quot;@monshaat/portal-api&quot;;
  2: import { z } from &quot;zod&quot;;
  3: import { post, PostResponse } from &quot;./post&quot;;
  4: 
  5: 
  6: export type Endpoint = keyof typeof allEndpoints;
  7: export type Operation = &quot;list&quot; | &quot;details&quot; | &quot;create&quot;;
  8: export const getFormAction = (endpoint: Endpoint, operation: Operation) =&gt; {
  9:   // const { details, list, create } = allEndpoints[endpoint];
 10:   const { details, list } = allEndpoints[endpoint];
 11:   const {
 12:     requestSchema: detailsRequestSchema,
 13:     responseSchema: detailsResponseSchema,
 14:     url: detailsURl,
 15:   } = details;
 16:   const {
 17:     requestSchema: listRequestSchema,
 18:     responseSchema: listResponseSchema,
 19:     url: listUrl,
 20:   } = list;
 21: 
 22:   let requestSchema: typeof detailsRequestSchema | typeof listRequestSchema;
 23:   let responseSchema: typeof detailsResponseSchema | typeof listResponseSchema;
 24:   let url: string;
 25: 
 26:   switch (operation) {
 27:     case &quot;details&quot;:
 28:       url = detailsURl;
 29:       requestSchema = detailsRequestSchema;
 30:       responseSchema = detailsResponseSchema;
 31:       break;
 32:     case &quot;list&quot;:
 33:       url = listUrl;
 34:       requestSchema = listRequestSchema;
 35:       responseSchema = listResponseSchema;
 36:       break;
 37:     default:
 38:       throw new Error(&quot;requestSchemaInvalid operation&quot;);
 39:   }
 40: 
 41:   type RequestBody = z.infer&lt;typeof requestSchema&gt;;
 42:   type ResponseBody = z.infer&lt;typeof responseSchema&gt;;
 43: 
 44:   const validateRequestBody = (body: unknown): RequestBody =&gt; {
 45:     const validatedBody = requestSchema.parse(body);
 46:     return validatedBody;
 47:   };
 48: 
 49:   const vaidateResponseBody = (body: unknown): ResponseBody =&gt; {
 50:     const validatedBody = responseSchema.parse(body);
 51:     return validatedBody;
 52:   };
 53: 
 54:   const postFunction = async (body: RequestBody) =&gt; {
 55:     const response = await post({
 56:       url,
 57:       body,
 58:     });
 59:     return response;
 60:   };
 61: 
 62:   type FormActionReturn = {
 63:     data: ResponseBody | null;
 64:     metaData: PostResponse | null;
 65:     error: string | null;
 66:     operation: string;
 67:     endpoint: string;
 68:     validationError: string | null;
 69:   };
 70: 
 71:   const formAction = async (formData: FormData): Promise&lt;FormActionReturn&gt; =&gt; {
 72:     const body = Object.fromEntries(formData);
 73: 
 74:     const formActionReturn: FormActionReturn = {
 75:       endpoint,
 76:       operation,
 77:       data: null,
 78:       error: null,
 79:       validationError: null,
 80:       metaData: null,
 81:     };
 82: 
 83:     let metaData: PostResponse | null = null;
 84:     let validResponseBody: ResponseBody;
 85:     let validRequestBody: RequestBody;
 86: 
 87:     try {
 88:       let id: number | string = body.id?.toString();
 89:       let employee_id: number | string = body.employee_id?.toString();
 90: 
 91:       if (id) {
 92:         id = parseInt(id);
 93:       }
 94: 
 95:       if (employee_id) {
 96:         employee_id = parseInt(employee_id);
 97:       }
 98: 
 99:       validRequestBody = validateRequestBody({ ...body, id, employee_id });
100:       // eslint-disable-next-line @typescript-eslint/no-unused-vars
101:     } catch (e: unknown) {
102:       formActionReturn.error = &quot;Error in validateRequestBody&quot;;
103:       formActionReturn.validationError =
104:         e instanceof Error ? e.message : &quot;Error in vaidateResponseBody&quot;;
105:       return formActionReturn;
106:     }
107: 
108:     try {
109:       metaData = await postFunction(validRequestBody);
110:       formActionReturn.metaData = metaData;
111:       const postFunctionError = metaData?.response.error;
112:       if (postFunctionError) {
113:         formActionReturn.error = postFunctionError;
114:         return formActionReturn;
115:       }
116:       // eslint-disable-next-line @typescript-eslint/no-unused-vars
117:     } catch (e: unknown) {
118:       formActionReturn.error = &quot;Errorin postFunction&quot;;
119:       formActionReturn.validationError =
120:         e instanceof Error ? e.message : &quot;Error in vaidateResponseBody&quot;;
121:       return formActionReturn;
122:     }
123: 
124:     try {
125:       const { response } = metaData;
126:       const { responseJson } = response;
127:       validResponseBody = vaidateResponseBody(responseJson);
128:       formActionReturn.data = validResponseBody;
129:       // eslint-disable-next-line @typescript-eslint/no-unused-vars
130:     } catch (e: unknown) {
131:       formActionReturn.error = metaData.response.error;
132:       formActionReturn.validationError =
133:         e instanceof Error ? e.message : &quot;Error in vaidateResponseBody&quot;;
134:       return formActionReturn;
135:     }
136:     return formActionReturn;
137:   };
138: 
139:   return formAction;
140: };</file><file path="packages/prompts/getPlanPrompt.ts"> 1: export const getPlanPrompt = (task: string) =&gt; {
 2:   const prompt = `Given this task: &quot;${task}&quot;, provide a list of steps to achieve it, reply only using the following json format: 
 3:         {
 4:                 &quot;task&quot;: &quot;main task description&quot;,
 5:                 &quot;taskName&quot;: &quot;uniqueTaskIdentifier&quot;,
 6:                 &quot;howToTest&quot;: &quot;how to test the main task&quot;,
 7:                 &quot;command&quot;: &quot;command to execute task &amp;&amp; command to test it || echo &apos;Test failed: main task&apos;&quot;,
 8:                 &quot;steps&quot;: [
 9:                         {
10:                                 &quot;task&quot;: &quot;step description&quot;,
11:                                 &quot;taskName&quot;: &quot;uniqueStepIdentifier&quot;,
12:                                 &quot;dependsOn&quot;: [&quot;taskNameThatNeedsToBeCompletedFirst&quot;],
13:                                 &quot;howToTest&quot;: &quot;how to test this step&quot;,
14:                                 &quot;command&quot;: &quot;command to execute step &amp;&amp; command to test it || echo &apos;Test failed: step description&apos;&quot;,
15:                                 &quot;steps&quot;: [] // nested steps follow the same structure
16:                         }
17:                 ]
18:         }`;
19: 
20:   return prompt;
21: };</file><file path="packages/prompts/getSplitTaskPrompt.ts"> 1: // parent: number, // parent task name
 2: // add depends on [...tasks].
 3: // const returnSchema = `{
 4: //     name: string, // name of the task
 5: //     description: string, // description of the task
 6: //     usefulLinks: string[], // links to resources that can help with the task
 7: // }`;
 8: 
 9: // const SPLIT_TASK_PROMPT = `Divide task into two subtasks unless the task is too simple to divide further, only reply with a json array of the following object schema: ${returnSchema}, `;
10: export const getSubTasksPrompt = (task: string) =&gt;
11:   `Divide the following function into multiple functions only if necessary, if the function is simple enough to be implemeneted without being split into smaller functions return the same function: ${task}`;</file><file path="packages/prompts/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/prompts&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 8:     &quot;bun-types&quot;: &quot;latest&quot;,
 9:     &quot;zod&quot;: &quot;1&quot;
10:   }
11: }</file><file path="packages/prompts/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;esnext&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path="packages/scripts/coder.ts">  1: import { SchemaType } from &quot;@google/generative-ai&quot;;
  2: import { getAiResponse } from &quot;./getAiResponse&quot;;
  3: import { getSubTasksPrompt } from &quot;./prompts/getSplitTaskPrompt&quot;;
  4: import { sleep } from &quot;./sleep&quot;;
  5: import { z } from &quot;zod&quot;;
  6: import { write } from &quot;bun&quot;;
  7: 
  8: // Define a zod schema for each task.
  9: const zodSchema = z.object({
 10:   isBasicTask: z.boolean(),
 11:   description: z.string(),
 12:   name: z.string(),
 13:   pseudocode: z.string(),
 14: });
 15: 
 16: // Define the expected JSON schema for the API response.
 17: const schema = {
 18:   description: &quot;List of sub tasks&quot;,
 19:   type: SchemaType.ARRAY,
 20:   items: {
 21:     type: SchemaType.OBJECT,
 22:     properties: {
 23:       name: {
 24:         type: SchemaType.STRING,
 25:         description: &quot;Name of the sub task&quot;,
 26:         nullable: false,
 27:       },
 28:       description: {
 29:         type: SchemaType.STRING,
 30:         description: &quot;Description of the sub task&quot;,
 31:         nullable: false,
 32:       },
 33:       isBasicTask: {
 34:         type: SchemaType.BOOLEAN,
 35:         description:
 36:           &quot;Whether the task is simple enough to not be divided further. If so, this should be true.&quot;,
 37:         nullable: false,
 38:       },
 39:       pseudocode: {
 40:         type: SchemaType.STRING,
 41:         description: &quot;Pseudo code for the task&quot;,
 42:         nullable: false,
 43:       },
 44:     },
 45:     required: [&quot;name&quot;, &quot;description&quot;, &quot;isBasicTask&quot;, &quot;pseudocode&quot;],
 46:   },
 47: };
 48: 
 49: // This function sends the task to the AI and returns a JSON string representing an array of sub tasks.
 50: export const splitTask = async (task: string): Promise&lt;string&gt; =&gt; {
 51:   const prompt = getSubTasksPrompt(task);
 52:   const tasks = await getAiResponse({
 53:     task,
 54:     prompt,
 55:     responseMimeType: &quot;application/json&quot;,
 56:     responseSchema: schema,
 57:   });
 58:   return tasks;
 59: };
 60: 
 61: // Define the basic task type returned by splitTask.
 62: export type TaskResult = {
 63:   name: string;
 64:   description: string;
 65:   isBasicTask: boolean;
 66: };
 67: 
 68: // Define the tree node type.
 69: export type TaskNode = {
 70:   task: TaskResult;
 71:   subTasks: TaskNode[];
 72: };
 73: 
 74: // Global constant for maximum recursive depth.
 75: const MAX_RECURSIVE_DEPTH = 10;
 76: 
 77: /**
 78:  * Recursively builds a tree branch for a given task.
 79:  *
 80:  * @param task - The current task to process.
 81:  * @param currentDepth - The current depth in the recursion.
 82:  * @returns A TaskNode representing the task and its (possibly recursive) subtasks.
 83:  */
 84: const buildSubTree = async (
 85:   task: TaskResult,
 86:   currentDepth: number
 87: ): Promise&lt;TaskNode&gt; =&gt; {
 88:   // Stop recursion if the task is basic or we&apos;ve reached the maximum depth.
 89:   if (task.isBasicTask || currentDepth &gt;= MAX_RECURSIVE_DEPTH) {
 90:     return { task, subTasks: [] };
 91:   }
 92: 
 93:   // Call splitTask to get the subtasks.
 94:   const responseString = await splitTask(task.description);
 95:   let subTaskResults: TaskResult[] = JSON.parse(responseString).map(
 96:     (item: any) =&gt; zodSchema.parse(item)
 97:   );
 98: 
 99:   // Limit to at most 2 subtasks.
100:   subTaskResults = subTaskResults.slice(0, 2);
101: 
102:   // Recursively process each subtask.
103:   const children: TaskNode[] = [];
104:   for (const subTask of subTaskResults) {
105:     const childNode = await buildSubTree(subTask, currentDepth + 1);
106:     children.push(childNode);
107:   }
108: 
109:   return { task, subTasks: children };
110: };
111: 
112: /**
113:  * Builds the complete task tree starting from an initial task string.
114:  *
115:  * The root node is created from the initial string, then splitTask is called
116:  * to generate the first level of subtasks.
117:  *
118:  * @param initialTask - The initial task as a string.
119:  * @returns A TaskNode representing the full tree.
120:  */
121: export const buildTaskTree = async (initialTask: string): Promise&lt;TaskNode&gt; =&gt; {
122:   // Create a root TaskResult from the input string.
123:   const rootTask: TaskResult = {
124:     name: initialTask,
125:     description: initialTask,
126:     isBasicTask: false,
127:   };
128: 
129:   // Split the root task into subtasks.
130:   const responseString = await splitTask(initialTask);
131:   let subTaskResults: TaskResult[] = JSON.parse(responseString).map(
132:     (item: any) =&gt; zodSchema.parse(item)
133:   );
134: 
135:   // Limit to at most 2 subtasks.
136:   subTaskResults = subTaskResults.slice(0, 2);
137: 
138:   // Build the children recursively.
139:   const children: TaskNode[] = [];
140:   for (const subTask of subTaskResults) {
141:     const childNode = await buildSubTree(subTask, 1);
142:     children.push(childNode);
143:   }
144: 
145:   return { task: rootTask, subTasks: children };
146: };
147: 
148: // Ujge example:
149: const MAIN_TASK = &quot;make a cup of tea&quot;;
150: 
151: const taskTree = await buildTaskTree(MAIN_TASK);
152: console.dir({ taskTree });
153: const taskTreeFilePath =
154:   &quot;./taskTrees/&quot; + Date.now() + MAIN_TASK.replaceAll(&quot; &quot;, &quot;_&quot;) + &quot;.json&quot;;
155: write(taskTreeFilePath, JSON.stringify(taskTree));
156: console.log(taskTreeFilePath);</file><file path="packages/scripts/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/scripts&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;bun-types&quot;: &quot;latest&quot;,
 8:     &quot;zod&quot;: &quot;3&quot;,
 9:     &quot;@ronin/actions&quot;: &quot;workspace:*&quot;,
10:     &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
11:     &quot;@ronin/utils&quot;: &quot;workspace:*&quot;
12:   }
13: }</file><file path="packages/scripts/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;esnext&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path="packages/test/server/actions/testExecuteCommand.ts">1: import { executeCommand } from &quot;../../../actions/server/executeCommand&quot;;
2: 
3: const command = &quot;echo Hello, world!&quot;;
4: const output = await executeCommand(command);
5: console.log(output); // Hello, world!</file><file path="packages/test/server/actions/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;esnext&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path="packages/test/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/test&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;@ronin/actions&quot;: &quot;workspace:*&quot;,
 8:     &quot;bun-types&quot;: &quot;latest&quot;,
 9:     &quot;zod&quot;: &quot;3&quot;
10:   }
11: }</file><file path="packages/test/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;esnext&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path="packages/utils/package.json"> 1: {
 2:   &quot;name&quot;: &quot;@ronin/utils&quot;,
 3:   &quot;version&quot;: &quot;0.0.1&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;dependencies&quot;: {
 7:     &quot;bun-types&quot;: &quot;latest&quot;,
 8:     &quot;zod&quot;: &quot;3&quot;,
 9:     &quot;@ronin/actions&quot;: &quot;workspace:*&quot;,
10:     &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
11:     &quot;@ronin/utils&quot;: &quot;workspace:*&quot;
12:   }
13: }</file><file path="packages/utils/sleep.ts">1: export const sleep = (s: number) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, s * 1000));</file><file path="packages/utils/tsconfig.json"> 1: {
 2:     &quot;compilerOptions&quot;: {
 3:       &quot;lib&quot;: [
 4:         &quot;ESNext&quot;
 5:       ],
 6:       &quot;module&quot;: &quot;esnext&quot;,
 7:       &quot;target&quot;: &quot;esnext&quot;,
 8:       &quot;moduleResolution&quot;: &quot;esnext&quot;,
 9:       &quot;strict&quot;: true,
10:       &quot;downlevelIteration&quot;: true,
11:       &quot;skipLibCheck&quot;: true,
12:       &quot;jsx&quot;: &quot;preserve&quot;,
13:       &quot;allowSyntheticDefaultImports&quot;: true,
14:       &quot;forceConsistentCasingInFileNames&quot;: true,
15:       &quot;allowJs&quot;: true,
16:       &quot;types&quot;: [
17:         &quot;bun-types&quot; // add Bun global
18:       ]
19:     }
20:   }</file><file path=".gitignore">  1: # Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore
  2: 
  3: # Logs
  4: 
  5: logs
  6: _.log
  7: npm-debug.log_
  8: yarn-debug.log*
  9: yarn-error.log*
 10: lerna-debug.log*
 11: .pnpm-debug.log*
 12: 
 13: # Caches
 14: 
 15: .cache
 16: 
 17: # Diagnostic reports (https://nodejs.org/api/report.html)
 18: 
 19: report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json
 20: 
 21: # Runtime data
 22: 
 23: pids
 24: _.pid
 25: _.seed
 26: *.pid.lock
 27: 
 28: # Directory for instrumented libs generated by jscoverage/JSCover
 29: 
 30: lib-cov
 31: 
 32: # Coverage directory used by tools like istanbul
 33: 
 34: coverage
 35: *.lcov
 36: 
 37: # nyc test coverage
 38: 
 39: .nyc_output
 40: 
 41: # Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
 42: 
 43: .grunt
 44: 
 45: # Bower dependency directory (https://bower.io/)
 46: 
 47: bower_components
 48: 
 49: # node-waf configuration
 50: 
 51: .lock-wscript
 52: 
 53: # Compiled binary addons (https://nodejs.org/api/addons.html)
 54: 
 55: build/Release
 56: 
 57: # Dependency directories
 58: 
 59: node_modules/
 60: jspm_packages/
 61: 
 62: # Snowpack dependency directory (https://snowpack.dev/)
 63: 
 64: web_modules/
 65: 
 66: # TypeScript cache
 67: 
 68: *.tsbuildinfo
 69: 
 70: # Optional npm cache directory
 71: 
 72: .npm
 73: 
 74: # Optional eslint cache
 75: 
 76: .eslintcache
 77: 
 78: # Optional stylelint cache
 79: 
 80: .stylelintcache
 81: 
 82: # Microbundle cache
 83: 
 84: .rpt2_cache/
 85: .rts2_cache_cjs/
 86: .rts2_cache_es/
 87: .rts2_cache_umd/
 88: 
 89: # Optional REPL history
 90: 
 91: .node_repl_history
 92: 
 93: # Output of &apos;npm pack&apos;
 94: 
 95: *.tgz
 96: 
 97: # Yarn Integrity file
 98: 
 99: .yarn-integrity
100: 
101: # dotenv environment variable files
102: 
103: .env
104: .env.development.local
105: .env.test.local
106: .env.production.local
107: .env.local
108: 
109: # parcel-bundler cache (https://parceljs.org/)
110: 
111: .parcel-cache
112: 
113: # Next.js build output
114: 
115: .next
116: out
117: 
118: # Nuxt.js build / generate output
119: 
120: .nuxt
121: dist
122: 
123: # Gatsby files
124: 
125: # Comment in the public line in if your project uses Gatsby and not Next.js
126: 
127: # https://nextjs.org/blog/next-9-1#public-directory-support
128: 
129: # public
130: 
131: # vuepress build output
132: 
133: .vuepress/dist
134: 
135: # vuepress v2.x temp and cache directory
136: 
137: .temp
138: 
139: # Docusaurus cache and generated files
140: 
141: .docusaurus
142: 
143: # Serverless directories
144: 
145: .serverless/
146: 
147: # FuseBox cache
148: 
149: .fusebox/
150: 
151: # DynamoDB Local files
152: 
153: .dynamodb/
154: 
155: # TernJS port file
156: 
157: .tern-port
158: 
159: # Stores VSCode versions used for testing VSCode extensions
160: 
161: .vscode-test
162: 
163: # yarn v2
164: 
165: .yarn/cache
166: .yarn/unplugged
167: .yarn/build-state.yml
168: .yarn/install-state.gz
169: .pnp.*
170: 
171: # IntelliJ based IDEs
172: .idea
173: 
174: # Finder (MacOS) folder config
175: .DS_Store</file><file path="bun.lock">  1: {
  2:   &quot;lockfileVersion&quot;: 1,
  3:   &quot;workspaces&quot;: {
  4:     &quot;&quot;: {
  5:       &quot;name&quot;: &quot;ronin&quot;,
  6:     },
  7:     &quot;packages/actions&quot;: {
  8:       &quot;name&quot;: &quot;@ronin/actions&quot;,
  9:       &quot;version&quot;: &quot;0.0.1&quot;,
 10:       &quot;dependencies&quot;: {
 11:         &quot;@google/generative-ai&quot;: &quot;^0.21.0&quot;,
 12:         &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 13:         &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 14:         &quot;bun-types&quot;: &quot;latest&quot;,
 15:         &quot;zod&quot;: &quot;1&quot;,
 16:       },
 17:     },
 18:     &quot;packages/archieve&quot;: {
 19:       &quot;name&quot;: &quot;@ronin/archieve&quot;,
 20:       &quot;version&quot;: &quot;0.0.1&quot;,
 21:       &quot;dependencies&quot;: {
 22:         &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 23:         &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 24:         &quot;bun-types&quot;: &quot;latest&quot;,
 25:         &quot;zod&quot;: &quot;1&quot;,
 26:       },
 27:     },
 28:     &quot;packages/config&quot;: {
 29:       &quot;name&quot;: &quot;@ronin/config&quot;,
 30:       &quot;version&quot;: &quot;0.0.1&quot;,
 31:       &quot;dependencies&quot;: {
 32:         &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 33:         &quot;bun-types&quot;: &quot;latest&quot;,
 34:         &quot;zod&quot;: &quot;1&quot;,
 35:       },
 36:     },
 37:     &quot;packages/hooks&quot;: {
 38:       &quot;name&quot;: &quot;@ronin/hooks&quot;,
 39:       &quot;version&quot;: &quot;0.0.1&quot;,
 40:       &quot;dependencies&quot;: {
 41:         &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 42:         &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 43:         &quot;bun-types&quot;: &quot;latest&quot;,
 44:         &quot;zod&quot;: &quot;1&quot;,
 45:       },
 46:     },
 47:     &quot;packages/prompts&quot;: {
 48:       &quot;name&quot;: &quot;@ronin/prompts&quot;,
 49:       &quot;version&quot;: &quot;0.0.1&quot;,
 50:       &quot;dependencies&quot;: {
 51:         &quot;@ronin/config&quot;: &quot;workspace:*&quot;,
 52:         &quot;bun-types&quot;: &quot;latest&quot;,
 53:         &quot;zod&quot;: &quot;1&quot;,
 54:       },
 55:     },
 56:     &quot;packages/scripts&quot;: {
 57:       &quot;name&quot;: &quot;@ronin/scripts&quot;,
 58:       &quot;version&quot;: &quot;0.0.1&quot;,
 59:       &quot;dependencies&quot;: {
 60:         &quot;@ronin/actions&quot;: &quot;workspace:*&quot;,
 61:         &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 62:         &quot;@ronin/utils&quot;: &quot;workspace:*&quot;,
 63:         &quot;bun-types&quot;: &quot;latest&quot;,
 64:         &quot;zod&quot;: &quot;3&quot;,
 65:       },
 66:     },
 67:     &quot;packages/test&quot;: {
 68:       &quot;name&quot;: &quot;@ronin/test&quot;,
 69:       &quot;version&quot;: &quot;0.0.1&quot;,
 70:       &quot;dependencies&quot;: {
 71:         &quot;@ronin/actions&quot;: &quot;workspace:*&quot;,
 72:         &quot;bun-types&quot;: &quot;latest&quot;,
 73:         &quot;zod&quot;: &quot;3&quot;,
 74:       },
 75:     },
 76:     &quot;packages/utils&quot;: {
 77:       &quot;name&quot;: &quot;@ronin/utils&quot;,
 78:       &quot;version&quot;: &quot;0.0.1&quot;,
 79:       &quot;dependencies&quot;: {
 80:         &quot;@ronin/actions&quot;: &quot;workspace:*&quot;,
 81:         &quot;@ronin/prompts&quot;: &quot;workspace:*&quot;,
 82:         &quot;@ronin/utils&quot;: &quot;workspace:*&quot;,
 83:         &quot;bun-types&quot;: &quot;latest&quot;,
 84:         &quot;zod&quot;: &quot;3&quot;,
 85:       },
 86:     },
 87:   },
 88:   &quot;packages&quot;: {
 89:     &quot;@google/generative-ai&quot;: [&quot;@google/generative-ai@0.21.0&quot;, &quot;&quot;, {}, &quot;sha512-7XhUbtnlkSEZK15kN3t+tzIMxsbKm/dSkKBFalj+20NvPKe1kBY7mR2P7vuijEn+f06z5+A8bVGKO0v39cr6Wg==&quot;],
 90: 
 91:     &quot;@ronin/actions&quot;: [&quot;@ronin/actions@workspace:packages/actions&quot;],
 92: 
 93:     &quot;@ronin/archieve&quot;: [&quot;@ronin/archieve@workspace:packages/archieve&quot;],
 94: 
 95:     &quot;@ronin/config&quot;: [&quot;@ronin/config@workspace:packages/config&quot;],
 96: 
 97:     &quot;@ronin/hooks&quot;: [&quot;@ronin/hooks@workspace:packages/hooks&quot;],
 98: 
 99:     &quot;@ronin/prompts&quot;: [&quot;@ronin/prompts@workspace:packages/prompts&quot;],
100: 
101:     &quot;@ronin/scripts&quot;: [&quot;@ronin/scripts@workspace:packages/scripts&quot;],
102: 
103:     &quot;@ronin/test&quot;: [&quot;@ronin/test@workspace:packages/test&quot;],
104: 
105:     &quot;@ronin/utils&quot;: [&quot;@ronin/utils@workspace:packages/utils&quot;],
106: 
107:     &quot;@types/node&quot;: [&quot;@types/node@22.13.4&quot;, &quot;&quot;, { &quot;dependencies&quot;: { &quot;undici-types&quot;: &quot;~6.20.0&quot; } }, &quot;sha512-ywP2X0DYtX3y08eFVx5fNIw7/uIv8hYUKgXoK8oayJlLnKcRfEYCxWMVE1XagUdVtCJlZT1AU4LXEABW+L1Peg==&quot;],
108: 
109:     &quot;@types/ws&quot;: [&quot;@types/ws@8.5.14&quot;, &quot;&quot;, { &quot;dependencies&quot;: { &quot;@types/node&quot;: &quot;*&quot; } }, &quot;sha512-bd/YFLW+URhBzMXurx7lWByOu+xzU9+kb3RboOteXYDfW+tr+JZa99OyNmPINEGB/ahzKrEuc8rcv4gnpJmxTw==&quot;],
110: 
111:     &quot;bun-types&quot;: [&quot;bun-types@1.2.2&quot;, &quot;&quot;, { &quot;dependencies&quot;: { &quot;@types/node&quot;: &quot;*&quot;, &quot;@types/ws&quot;: &quot;~8.5.10&quot; } }, &quot;sha512-RCbMH5elr9gjgDGDhkTTugA21XtJAy/9jkKe/G3WR2q17VPGhcquf9Sir6uay9iW+7P/BV0CAHA1XlHXMAVKHg==&quot;],
112: 
113:     &quot;undici-types&quot;: [&quot;undici-types@6.20.0&quot;, &quot;&quot;, {}, &quot;sha512-Ny6QZ2Nju20vw1SRHe3d9jVu6gJ+4e3+MMpqu7pqE5HT6WsTSlce++GQmK5UXS8mzV8DSYHrQH+Xrf2jVcuKNg==&quot;],
114: 
115:     &quot;zod&quot;: [&quot;zod@1.11.17&quot;, &quot;&quot;, {}, &quot;sha512-UzIwO92D0dSFwIRyyqAfRXICITLjF0IP8tRbEK/un7adirMssWZx8xF/1hZNE7t61knWZ+lhEuUvxlu2MO8qqA==&quot;],
116: 
117:     &quot;@ronin/scripts/zod&quot;: [&quot;zod@3.24.2&quot;, &quot;&quot;, {}, &quot;sha512-lY7CDW43ECgW9u1TcT3IoXHflywfVqDYze4waEz812jR/bZ8FHDsl7pFQoSZTz5N+2NqRXs8GBwnAwo3ZNxqhQ==&quot;],
118: 
119:     &quot;@ronin/test/zod&quot;: [&quot;zod@3.24.2&quot;, &quot;&quot;, {}, &quot;sha512-lY7CDW43ECgW9u1TcT3IoXHflywfVqDYze4waEz812jR/bZ8FHDsl7pFQoSZTz5N+2NqRXs8GBwnAwo3ZNxqhQ==&quot;],
120: 
121:     &quot;@ronin/utils/zod&quot;: [&quot;zod@3.24.2&quot;, &quot;&quot;, {}, &quot;sha512-lY7CDW43ECgW9u1TcT3IoXHflywfVqDYze4waEz812jR/bZ8FHDsl7pFQoSZTz5N+2NqRXs8GBwnAwo3ZNxqhQ==&quot;],
122:   }
123: }</file><file path="index.ts"> 1: // // import read from &quot;node-read&quot;;
 2: // import { file, write } from &quot;bun&quot;;
 3: // import { input } from &quot;@inquirer/prompts&quot;;
 4: // import { getAiResponse } from &quot;./getAiResponse&quot;;
 5: 
 6: // // const TurndownService = require(&quot;turndown&quot;);
 7: // // const turndownService = new TurndownService();
 8: // // const url = &quot;https://wiki.archlinux.org/title/Installation_guide&quot;;
 9: 
10: // // const fetchResponse = await fetch(url);
11: // // const html = await fetchResponse.text();
12: // // const markdown = turndownService.turndown(html);
13: // // const path = &quot;arch_linux_installation_guide.md&quot;;
14: // // const mdFile = file(&quot;data/&quot; + path);
15: // // await write(mdFile, markdown);
16: 
17: // const userPrompt = await input({ message: &quot;&gt;&gt;&gt;&quot; });
18: 
19: // const googleSearchPage = await getAiResponse(
20: //   &quot;reply with a google search url for the following prompt, don&apos;t use the prompt as-is, modify it so that the google search is more relevent to the user&apos;s question,only reply with the url and nothing else!:&quot;,
21: //   userPrompt
22: // );
23: // console.log({ googleSearchPage });
24: 
25: // // const googleSearchResults = await fetch(googleSearchPage, {
26: // //   redirect: &quot;manual&quot;,
27: // //   method: &quot;GET&quot;,
28: // //   headers: {
29: // //     &quot;Content-Type&quot;: &quot;text/html&quot;,
30: // //     &quot;User-Agent&quot;:
31: // //       &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3&quot;,
32: // //   },
33: // // });
34: 
35: // // const googleSearchHtml = await googleSearchResults.text();
36: // // const googleSearchPath = &quot;google_search_results.html&quot;;
37: // // const googleSearchMdFile = file(&quot;data/&quot; + googleSearchPath);
38: // // await write(googleSearchMdFile, googleSearchHtml);
39: // // const googleSearchMarkdown = turndownService.turndown(googleSearchHtml);
40: // // const googleSearchMdFile = file(&quot;data/&quot; + googleSearchPath);
41: // // await write(googleSearchMdFile, googleSearchMarkdown);
42: 
43: // console.log({ googleSearchPage });
44: // // const aiResponse = await getAiResponse(userPrompt, markdown);
45: // // console.log(aiResponse);
46: 
47: // // console.log(markdown);
48: // // console.log(markdown);
49: // // type Article = {
50: // //   title: string;
51: // //   content: string;
52: // //   html: string;
53: // //   dom: string;
54: // // };
55: 
56: // // read(url, function (err: Error, article: Article, res: Response) {
57: // // const { title, content } = article;
58: // // Main Article.
59: // // console.log(article.content);
60: // // const markdown = turndownService.turndown(article.html);
61: // // const path = title.trim().replaceAll(&quot; &quot;, &quot;_&quot;).toLowerCase() + &quot;.md&quot;;
62: // // const mdFile = file(path);
63: // // write(&quot;data/&quot; + mdFile, markdown);
64: // // console.log(markdown);
65: 
66: // // Title
67: // // console.log(article.title);
68: 
69: // // HTML
70: // // console.log(article.html);
71: 
72: // // DOM
73: // // console.log(article.dom);
74: // // });</file><file path="package.json"> 1: {
 2:   &quot;name&quot;: &quot;ronin&quot;,
 3:   &quot;private&quot;: &quot;true&quot;,
 4:   &quot;module&quot;: &quot;index.ts&quot;,
 5:   &quot;type&quot;: &quot;module&quot;,
 6:   &quot;workspaces&quot;: [
 7:     &quot;packages/actions&quot;,
 8:     &quot;packages/archieve&quot;,
 9:     &quot;packages/config&quot;,
10:     &quot;packages/hooks&quot;,
11:     &quot;packages/utils&quot;,
12:     &quot;packages/scripts&quot;,
13:     &quot;packages/test&quot;,
14:     &quot;packages/prompts&quot;
15:   ],
16:   &quot;scripts&quot;: {
17:     &quot;clean&quot;: &quot;rm -rf node_modules packages/a/node_modules packages/b/node_modules bun.lockb packages/a/bun.lockb packages/b/bun.lockb&quot;
18:   }
19: }</file><file path="README.md">1: [LanguageX](packages/docs/ronin/LanguageX.md)</file><file path="tsconfig.json"> 1: {
 2:   &quot;compilerOptions&quot;: {
 3:     &quot;lib&quot;: [&quot;ESNext&quot;],
 4:     &quot;module&quot;: &quot;nodenext&quot;,
 5:     &quot;target&quot;: &quot;esnext&quot;,
 6:     &quot;moduleResolution&quot;: &quot;nodenext&quot;,
 7:     &quot;strict&quot;: true,
 8:     &quot;downlevelIteration&quot;: true,
 9:     &quot;skipLibCheck&quot;: true,
10:     &quot;jsx&quot;: &quot;preserve&quot;,
11:     &quot;allowSyntheticDefaultImports&quot;: true,
12:     &quot;forceConsistentCasingInFileNames&quot;: true,
13:     &quot;allowJs&quot;: true,
14:     &quot;types&quot;: [
15:       &quot;bun-types&quot; // add Bun global
16:     ]
17:   }
18: }</file></files></repomix>